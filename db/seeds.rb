# This file should contain all the record creation needed to seed the database with its default values.
# The data can then be loaded with the bin/rails db:seed command (or created alongside the database with db:setup).
#
# Examples:
#
#   movies = Movie.create([{ name: 'Star Wars' }, { name: 'Lord of the Rings' }])
#   Character.create(name: 'Luke', movie: movies.first)

Flashcard.create!([
    {category: "Java Building Blocks",
    question: "What is a Class in Java?",
    answer: "Classes are the main building-blocks of Java Programs."},
    {category: "Java Building Blocks",
    question: "What are the three types of comments?",
    answer: "The three types: <br> - Single line - begin with two slashes <code>//</code>.<br>
    - Multi line - begin with <code>/*</code> and end with <code>*/</code>.<br>
    - Java-doc - begins with <code>/</code> and ends with <code>*/</code>. It is special and understood by the Java-doc tool."},
    {category: "Java Building Blocks",
    question: "What is an object in Java?",
    answer: "An object is a runtime instance of a class in memory."},
    {category: "Java Building Blocks",
    question: "How many public classes can a Java file have?",
    answer: "Multiple classes can be in one file but at least one must be <code>public</code> and match the file name, otherwise it won't compile."},
    {category: "Java Building Blocks",
    question: "What gets generated by comiling a .java file?",
    answer: "Compiling a <code>.java</code> by typing <code>javac className.java</code> turns it into a <code>.class</code>."},
    {category: "Java Building Blocks",
    question: "How do you enter argunemts in the compiler?",
    answer: "Arguments are separated by space in the terminal, and arguments with a space need to be in quotes."},
    {category: "Java Building Blocks",
    question: "How do you declare an instance method?",
    answer: "Declaring an instance method happens by writing <code>new</code> in front of the name of the method with <code>()</code>."},
    {category: "Java Building Blocks",
    question: "Do wildcards imports slow down the programm?",
    answer: "They don't slow down the program because the compiler figures out which packages it needs."},
    {category: "Java Building Blocks",
    question: "What are instance initializers?",
    answer: "Instance initializers are code-blocks outside of methods."},
    {category: "Java Building Blocks",
    question: "What are the eight different primitive types?",
    answer: "There are 8 different primitive types: <br>
    1. <code>boolean</code>, true or false. <br>
    2. <code>byte</code>, 8-bits integral value, min. value = -128 & max. value = 127. <br>
    3. <code>short</code>, 16-bits integral value.<br>
    4. <code>int</code>, 32-bits integral value.<br>
    5. <code>long</code>, 64-bits integral value.<br>
    6. <code>float</code>, 32-bits floating-point value.<br>
    7. <code>double</code>, 64-bits floating-point value.<br>
    8. <code>char</code>, 16-bits."},
    {category: "Java Building Blocks",
    question: "What is the order of initialization when creating a new object?",
    answer: "1. First instance initializers and fields are run in the order they appear in. <br>
    2. Than the constructor is run. <br>
    3. Than the <code>main()</code>."},
    {category: "Java Building Blocks",
    question: "What are the different base types?",
    answer: "Different Base types: <br>
    - Base 10. (0-9). <br>
    - Hexadecimal, with a prefix of 0X or 0x (0-9 and A-F).<br>
    - Binary, 0b or 0B. (0-1)<br>
    - Octal, prefix 0 (0-7)."},
    {category: "Java Building Blocks",
    question: "What are the rules for declaring a varable?",
    answer: "You can declare variable names in camel case with <code>$</code>, <code>_</code> and the alphabet."},
    {category: "Java Building Blocks",
    question: "When is an object garbage collected?",
    answer: "An object or a reference gets garbage collected when there is no reference pointing to an object, or the object goes out of scope."},
    {category: "Java Building Blocks",
    question: " What are the default values of: <br>
    - <code>boolean</code> <br>
    - <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code> <br>
    - <code>double</code>, <code>float</code> <br>
    - object references ",
    answer: "- <code>boolean</code> â†’ <code>false</code>. <br>
    - <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code> â†’ <code>0</code>. <br>
    - <code>double</code>, <code>float</code> â†’ <code>0.0</code>. <br>
    - object references â†’ <code>null</code>."}
    ])


puts "Creating: Java Building Blocks"
Material.create!([
    {category: "Java Building Blocks",
    sub_category: "Understanding the Java Class Structure",
    title: "",
        content: "Classes are the main building-blocks of Java Programs."},
    {category: "Java Building Blocks",
    sub_category: "Understanding the Java Class Structure",
    title: "",
        content: "An object is a runtime instance of a class in memory."},
    {category: "Java Building Blocks",
    sub_category: "Understanding the Java Class Structure",
    title: "",
        content: "To use a class I have to create an object. All various objects of all classes represent the state of the program."},
    {category: "Java Building Blocks",
    sub_category: "Understanding the Java Class Structure",
    title: "Fields and Methods",
        content: "Java classes are made up of methods and fields, these are called members of a class. Fields store the state, methods act on the state and modify it. If a change needs to be saved it is stored in a field."},
    {category: "Java Building Blocks",
    sub_category: "Understanding the Java Class Structure",
    title: "Fields and Methods",
        content: "A keyword is a special - reserved word in Java and it can't be used as a class or variable name."},
    {category: "Java Building Blocks",
    sub_category: "Understanding the Java Class Structure",
    title: "Fields and Methods",
        content: "A method is an operation that can be called."},
    {category: "Java Building Blocks",
    sub_category: "Understanding the Java Class Structure",
    title: "Fields and Methods",
        content: "A parameter is required information to be supplied when calling a method."},
    {category: "Java Building Blocks",
    sub_category: "Understanding the Java Class Structure",
    title: "Comments",
        content: "Comments aren't executable code and can be placed anywhere."},
    {category: "Java Building Blocks",
    sub_category: "Understanding the Java Class Structure",
    title: "Comments",
        content: "The three types: <br> - Single line - begin with two slashes <code>//</code>.<br>
    - Multi line - begin with <code>/*</code> and end with <code>*/</code>.<br>
    - Java-doc - begins with <code>/</code> and ends with <code>*/</code>. It is special and understood by the Java-doc tool."},
    {category: "Java Building Blocks",
    sub_category: "Understanding the Java Class Structure",
    title: "Classes vs. Files",
        content: "Almost every time a Java class is in its own <code>.java</code> file."},
    {category: "Java Building Blocks",
    sub_category: "Understanding the Java Class Structure",
    title: "Classes vs. Files",
        content: "It is mostly public, but Java accepts classes that are not public too."},
    {category: "Java Building Blocks",
    sub_category: "Understanding the Java Class Structure",
    title: "Classes vs. Files",
        content: "Multiple classes can be in one file but at least one must be <code>public</code> and match the file name, otherwise it won't compile."},
    {category: "Java Building Blocks",
    sub_category: "Writing a <code>main()</code> Method",
    title: "",
        content: "The <code>main()</code> method is the gateway between the startup of a Java process and the programmer's code. It is telling the underlying system to allocate CPU time, memory and so on."},
    {category: "Java Building Blocks",
    sub_category: "Writing a <code>main()</code> Method",
    title: "",
        content: "<code>public static void main(String[] args) {}</code> or <code>main(String args[])</code> or <code>main(String... args)</code> is the standard may to write the main method signature. <br>
    - <code>public</code> is an access modifier and means that any class from anywhere has access to that method.<br>
    - <code>static</code> binds the method to its class so it can be called by just the class name.<br>
    - <code>void</code> is a return type and says that the method doesn't return anything.<br>
    - <code>main</code> is the method name.<br>
    - <code>String</code> is a <code>java.lang.String</code> object, any input in the terminal will be read as a string.<br>
    - <code>(String args[])</code> is a parameter list."},
    {category: "Java Building Blocks",
    sub_category: "Writing a <code>main()</code> Method",
    title: "",
        content: "Arguments are separated by space in the terminal, and arguments with a space need to be in quotes."},
    {category: "Java Building Blocks",
    sub_category: "Writing a <code>main()</code> Method",
    title: "",
        content: "The brackets <code>[]</code> are a symbol for an array."},
    {category: "Java Building Blocks",
    sub_category: "Writing a <code>main()</code> Method",
    title: "",
        content: "<code>args</code> means arguments but can be anything."},
    {category: "Java Building Blocks",
    sub_category: "Writing a <code>main()</code> Method",
    title: "",
        content: "Java code is being compiled into bytecode and the JVM reads it."},
    {category: "Java Building Blocks",
    sub_category: "Writing a <code>main()</code> Method",
    title: "",
        content: "Compiling a <code>.java</code> by typing <code>javac className.java</code> turns it into a <code>.class</code>."},
    {category: "Java Building Blocks",
    sub_category: "Writing a <code>main()</code> Method",
    title: "",
        content: "<code>className</code> and <code>.java</code> filename have to be the same and case sensitively so."},
    {category: "Java Building Blocks",
    sub_category: "Writing a <code>main()</code> Method",
    title: "",
        content: "To run a Java program you type <code>java</code> and the <code>.class</code> name without <code>.class</code> at the end."},
    {category: "Java Building Blocks",
    sub_category: "Writing a <code>main()</code> Method",
    title: "",
        content: "To access an arrays objects, suffix <code>[0]</code> starting with zero and up."},
    {category: "Java Building Blocks",
    sub_category: "Understanding Package Declarations and Imports",
    title: "",
        content: "Java package names are hierarchical, from parent to child packages."},
    {category: "Java Building Blocks",
    sub_category: "Understanding Package Declarations and Imports",
    title: "Wildcards",
        content: "Classes from the same package are imported together using a wildcard <code>*</code>. "},
    {category: "Java Building Blocks",
    sub_category: "Understanding Package Declarations and Imports",
    title: "Wildcards",
        content: "They don't slow down the program because the compiler figures out which packages it needs."},
    {category: "Java Building Blocks",
    sub_category: "Understanding Package Declarations and Imports",
    title: "Wildcards",
        content: "It shortens the import list but it is more readable and understandable to the programmers if all the used packages are explicitly imported."},
    {category: "Java Building Blocks",
    sub_category: "Understanding Package Declarations and Imports",
    title: "Redundant Imports",
        content: "<code>java.lang</code> is a special package because it gets imported every time."},
    {category: "Java Building Blocks",
    sub_category: "Understanding Package Declarations and Imports",
    title: "Redundant Imports",
        content: "It is redundant to import classes twice, from a wild card and explicitly."},
    {category: "Java Building Blocks",
    sub_category: "Understanding Package Declarations and Imports",
    title: "Redundant Imports",
        content: "Classes get imported from packages but not class methods or folders of packages."},
    {category: "Java Building Blocks",
    sub_category: "Understanding Package Declarations and Imports",
    title: "Naming Conflicts",
        content: "If there are naming conflicts where I import the same class name from different packages by wildcard, Java throws an error. If we use an explicit name for the one and a wildcard for the other, it will work."},
    {category: "Java Building Blocks",
    sub_category: "Understanding Package Declarations and Imports",
    title: "Naming Conflicts",
        content: "If we need both, we always use both long names in the code."},
    {category: "Java Building Blocks",
    sub_category: "Understanding Package Declarations and Imports",
    title: "Creating a New Package",
        content: "First line of code: <code>package <package name>;</code> Is the folder within which the class is saved."},
    {category: "Java Building Blocks",
    sub_category: "Understanding Package Declarations and Imports",
    title: "Code Formatting on the Exam",
        content: "If code starts with line 1 and a necessary import is missing, the code does not compile."},
    {category: "Java Building Blocks",
    sub_category: "Creating Objects",
    title: "",
        content: "An object is an instance of a class."},
    {category: "Java Building Blocks",
    sub_category: "Creating Objects",
    title: "Constructors",
        content: "Declaring an instance method happens by writing <code>new</code> in front of the name of the method with <code>()</code>."},
    {category: "Java Building Blocks",
    sub_category: "Creating Objects",
    title: "Constructors",
        content: "<code>()</code> means that you have a constructor method."},
    {category: "Java Building Blocks",
    sub_category: "Creating Objects",
    title: "Constructors",
        content: "A constructor is a special type of method that creates a new object."},
    {category: "Java Building Blocks",
    sub_category: "Creating Objects",
    title: "Constructors",
        content: "Only constructor methods can be called by <code>new ConstrictorName();</code>."},
    {category: "Java Building Blocks",
    sub_category: "Creating Objects",
    title: "Constructors",
        content: "Example: <code>Random r = new Random();</code>. <br>
    - The first <code>Random</code> is the data type declaration, <code>r</code> is the object reference variable name <code>new</code> initializes the construction of the instance and <code>Random</code> is the constructor methods name;"},
    {category: "Java Building Blocks",
    sub_category: "Creating Objects",
    title: "Constructors",
        content: "The constructors name matches its class name and doesn't have a return type keyword."},
    {category: "Java Building Blocks",
    sub_category: "Creating Objects",
    title: "Constructors",
        content: "Fields can be declared in the constructor or in line (outside of it - in the class.)."},
    {category: "Java Building Blocks",
    sub_category: "Creating Objects",
    title: "Reading and Writing Object Fields",
        content: "It is possible to read and write variables directly form the caller."},
    {category: "Java Building Blocks",
    sub_category: "Creating Objects",
    title: "Reading and Writing Object Fields",
        content: "Reading is referred to as getting it and writing is referred to as setting it."},
    {category: "Java Building Blocks",
    sub_category: "Creating Objects",
    title: "Instance Initializer Blocks",
        content: "Code that is between curly braces is called a code block."},
    {category: "Java Building Blocks",
    sub_category: "Creating Objects",
    title: "Instance Initializer Blocks",
        content: "Instance initializers are code-blocks outside of methods."},
    {category: "Java Building Blocks",
    sub_category: "Creating Objects",
    title: "Instance Initializer Blocks",
        content: "The same number of opening and closing braces are necessary, otherwise the code doesn't compile."},
    {category: "Java Building Blocks",
    sub_category: "Creating Objects",
    title: "Order of Initialization",
        content: "1. First instance initializers and fields are run in the order they appear in. <br>
    2. Than the constructor is run. <br>
    3. Than the <code>main()</code>."},
    {category: "Java Building Blocks",
    sub_category: "Distinguishing Between Object References and Primitives",
    title: "",
        content: "Java applications contain two types of data: primitive types and reference types."},
    {category: "Java Building Blocks",
    sub_category: "Distinguishing Between Object References and Primitives",
    title: "Primitive Types",
        content: "There are 8 different primitive types: <br>
    1. <code>boolean</code>, true or false. <br>
    2. <code>byte</code>, 8-bits integral value, min. value = -128 & max. value = 127. <br>
    3. <code>short</code>, 16-bits integral value.<br>
    4. <code>int</code>, 32-bits integral value.<br>
    5. <code>long</code>, 64-bits integral value.<br>
    6. <code>float</code>, 32-bits floating-point value.<br>
    7. <code>double</code>, 64-bits floating-point value.<br>
    8. <code>char</code>, 16-bits."},
    {category: "Java Building Blocks",
    sub_category: "Distinguishing Between Object References and Primitives",
    title: "Primitive Types",
        content: "Floats require the letter <code>f</code> following the number."},
    {category: "Java Building Blocks",
    sub_category: "Distinguishing Between Object References and Primitives",
    title: "Primitive Types",
        content: "When a number is present in the code it's called a literal."},
    {category: "Java Building Blocks",
    sub_category: "Distinguishing Between Object References and Primitives",
    title: "Primitive Types",
        content: "Add a big <code>L</code> after a <code>long</code> number."},
    {category: "Java Building Blocks",
    sub_category: "Distinguishing Between Object References and Primitives",
    title: "Primitive Types",
        content: "Underscores in numbers are OK since Java 7, but they can't be at the beginning, end or next to a decimal point."},
    {category: "Java Building Blocks",
    sub_category: "Distinguishing Between Object References and Primitives",
    title: "Primitive Types",
        content: "Different Base types: <br>
    - Base 10. (0-9). <br>
    - Hexadecimal, with a prefix of 0X or 0x (0-9 and A-F).<br>
    - Binary, 0b or 0B. (0-1)<br>
    - Octal, prefix 0 (0-7)."},
    {category: "Java Building Blocks",
    sub_category: "Distinguishing Between Object References and Primitives",
    title: "Reference Types",
        content: "A reference type refers to an object or instance of a class."},
    {category: "Java Building Blocks",
    sub_category: "Distinguishing Between Object References and Primitives",
    title: "Reference Types",
        content: "References don't hold the value the of object they refer to."},
    {category: "Java Building Blocks",
    sub_category: "Distinguishing Between Object References and Primitives",
    title: "Reference Types",
        content: "Java stores the memory address of the object and one can't know the actual address in memory unlike other languages."},
    {category: "Java Building Blocks",
    sub_category: "Distinguishing Between Object References and Primitives",
    title: "Reference Types",
        content: "The reference address as well as the variable name are also known as a pointer."},
    {category: "Java Building Blocks",
    sub_category: "Distinguishing Between Object References and Primitives",
    title: "Reference Types",
        content: "Reference types can be reassigned to a different object from the same type or to a new object using the <code>new</code> keyword."},
    {category: "Java Building Blocks",
    sub_category: "Distinguishing Between Object References and Primitives",
    title: "Key Differences",
        content: "Reference types can be assigned <code>null</code>, primitive types can't."},
    {category: "Java Building Blocks",
    sub_category: "Distinguishing Between Object References and Primitives",
    title: "Key Differences",
        content: "All primitive types need to have lower-case variable names."},
    {category: "Java Building Blocks",
    sub_category: "Distinguishing Between Object References and Primitives",
    title: "Key Differences",
        content: "Methods can't be called on primitive types, only on reference objects."},
    {category: "Java Building Blocks",
    sub_category: "Declaring and Initializing Variables",
    title: "",
        content: "To declare a variable, I need to state the variable type and the name of the variable."},
    {category: "Java Building Blocks",
    sub_category: "Declaring and Initializing Variables",
    title: "",
        content: "To initialize a variable, I need to give it a value after an <code>=</code> assignment operator."},
    {category: "Java Building Blocks",
    sub_category: "Declaring and Initializing Variables",
    title: "",
        content: "Example: <code>int bananas = 3;</code>."},
    {category: "Java Building Blocks",
    sub_category: "Declaring and Initializing Variables",
    title: "Declaring Multiple Variables",
        content: "You can't declare the same type twice."},
    {category: "Java Building Blocks",
    sub_category: "Declaring and Initializing Variables",
    title: "Declaring Multiple Variables",
        content: "You can declare and initialize multiple variables on the same statement as long as they are from the same type."},
    {category: "Java Building Blocks",
    sub_category: "Declaring and Initializing Variables",
    title: "Identifiers",
        content: "You can declare variable names in camel case with <code>$</code>, <code>_</code> and the alphabet."},
    {category: "Java Building Blocks",
    sub_category: "Declaring and Initializing Variables",
    title: "Identifiers",
        content: "You can't use a reserved Java keyword."},
    {category: "Java Building Blocks",
    sub_category: "Understanding Default Initialization of Variables",
    title: "",
        content: "Some variables get a value set automatically, others don't."},
    {category: "Java Building Blocks",
    sub_category: "Understanding Default Initialization of Variables",
    title: "Local Variables",
        content: "Local variables are defined within a method."},
    {category: "Java Building Blocks",
    sub_category: "Understanding Default Initialization of Variables",
    title: "Local Variables",
        content: "Local variables are within the scope of the method and can't be called in an expression until initialized."},
    {category: "Java Building Blocks",
    sub_category: "Understanding Default Initialization of Variables",
    title: "Local Variables",
        content: "The compiler knows if a variable is declared and initialized and checks whether all the logical branches are initializing the eventually called variables."},
    {category: "Java Building Blocks",
    sub_category: "Understanding Default Initialization of Variables",
    title: "Local Variables",
        content: "Local variables have garbage data until initialized because they don't have a default value."},
    {category: "Java Building Blocks",
    sub_category: "Understanding Default Initialization of Variables",
    title: "Instance and Class Variables",
        content: "Variables that are not local are class or instance variables."},
    {category: "Java Building Blocks",
    sub_category: "Understanding Default Initialization of Variables",
    title: "Instance and Class Variables",
        content: "Instance variables are also known as fields."},
    {category: "Java Building Blocks",
    sub_category: "Understanding Default Initialization of Variables",
    title: "Instance and Class Variables",
        content: "Class variables can be shared between different objects."},
    {category: "Java Building Blocks",
    sub_category: "Understanding Default Initialization of Variables",
    title: "Instance and Class Variables",
        content: "Class variables have the keyword <code>static</code> in front of them."},
    {category: "Java Building Blocks",
    sub_category: "Understanding Default Initialization of Variables",
    title: "Instance and Class Variables",
        content: "By declaration they also get initialized with the default values: <br>
    - <code>boolean</code> â†’ <code>false</code>. <br>
    - <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code> â†’ <code>0</code>. <br>
    - <code>double</code>, <code>float</code> â†’ <code>0.0</code>. <br>
    - object references â†’ <code>null</code>."},
    {category: "Java Building Blocks",
    sub_category: "Understanding Variable Scope",
    title: "",
        content: "Instance variables - in scope the from declaration until object is garbage collected."},
    {category: "Java Building Blocks",
    sub_category: "Understanding Variable Scope",
    title: "",
        content: "Local variables - in scope from the declaration until end of the block."},
    {category: "Java Building Blocks",
    sub_category: "Understanding Variable Scope",
    title: "",
        content: "Class variables - in scope from the declaration until the program ends."},
    {category: "Java Building Blocks",
    sub_category: "Ordering Elements in a Class",
    title: "",
        content: "Order of declarations: <br>
    1. Package declaration. <br>
        - <code>package banana;</code> not required, first line.<br>
    2. Import statement.<br>
        - <code>import java.util.*;</code> not required.<br>
    3. Class declaration.<br>
        - <code>class Banana {};</code> required.<br>
            - Methods and fields must be within a class."},
    {category: "Java Building Blocks",
    sub_category: "Ordering Elements in a Class",
    title: "",
        content: "There can be more classes in a file but none, or at most one must be public."},
    {category: "Java Building Blocks",
    sub_category: "Destroying Objects",
    title: "",
        content: "Java deletes created objects automatically from the memory heap."},
    {category: "Java Building Blocks",
    sub_category: "Destroying Objects",
    title: "Garbage Collection",
        content: "An object or a reference gets garbage collected when there is no reference pointing to an object, or the object goes out of scope."},
    {category: "Java Building Blocks",
    sub_category: "Destroying Objects",
    title: "Garbage Collection",
        content: "Garbage collection happens when an object becomes obsolete."},
    {category: "Java Building Blocks",
    sub_category: "Destroying Objects",
    title: "Garbage Collection",
        content: "<code>System.gs</code> is not guaranteed to run, it is a suggestion for Java to run it."},
    {category: "Java Building Blocks",
    sub_category: "Destroying Objects",
    title: "Garbage Collection",
        content: "There is a difference between the references and their objects."},
    {category: "Java Building Blocks",
    sub_category: "Destroying Objects",
    title: "Garbage Collection",
        content: "All references can be passed through methods and are of the same size, which can be reassigned."},
    {category: "Java Building Blocks",
    sub_category: "Destroying Objects",
    title: "Garbage Collection",
        content: "Objects are on the memory heap of warring sizes."},
    {category: "Java Building Blocks",
    sub_category: "Destroying Objects",
    title: "Garbage Collection",
        content: "An object sits on the heap of the memory with no name until it gets called by the garbage collection."},
    {category: "Java Building Blocks",
    sub_category: "Destroying Objects",
    title: "<code>finalize()</code>",
        content: "Runs after the attempt of Java to do garbage collection, it might run, it might not, and it won't get called twice."},
    {category: "Java Building Blocks",
    sub_category: "Benefits of Java",
    title: "",
        content: "Object-oriented: All of the code in Java is in classes and classes can instantiate objects. It also allows for functional programming but everything is a class in Java."},
    {category: "Java Building Blocks",
    sub_category: "Benefits of Java",
    title: "",
        content: "Robust: It has no memory leaks like in C++."},
    {category: "Java Building Blocks",
    sub_category: "Benefits of Java",
    title: "",
        content: "Secure: It runs in the JVM, which is a sandbox preventing Java code to do harm to the computer."},
    {category: "Java Building Blocks",
    sub_category: "Benefits of Java",
    title: "",
        content: "Simple: No pointers and no operator overloading."},
    {category: "Java Building Blocks",
    sub_category: "Benefits of Java",
    title: "",
        content: "Encapsulation: Java allows for access modifiers to prevent data from getting accessed accidentally."},
    {category: "Java Building Blocks",
    sub_category: "Benefits of Java",
    title: "",
        content: "Platform independent: Write once run everywhere. Because it is an interpreted language, compiled into bytecode."}])
 
puts "ðŸ˜ŠCreated: Java Building Blocks"
puts "ðŸ¤”ðŸ¤”Creating: Operators and Statements"

Material.create!([
    {category: "Operators and Statements",
    sub_category: "Understanding Java Operators",
    title: "",
        content: "Operators are a special kind of symbol that Java understands as something to transform. "},
    {category: "Operators and Statements",
    sub_category: "Understanding Java Operators",
    title: "",
        content: "They act on operands â€” numbers, strings, literals, booleans."},
    {category: "Operators and Statements",
    sub_category: "Understanding Java Operators",
    title: "",
        content: "Standard operation direction is from left to right, but in some cases reversed."},
    {category: "Operators and Statements",
    sub_category: "Understanding Java Operators",
    title: "",
        content: "Types of operators for the OCA by their order of precedence: <br>
        1. Post-unary-operators: <code>expression++</code>. <br>
        2. Pre-unary-operators: <code>++expression</code>. <br>
        3. Other unary operators: <code>!</code> <code>-</code> <code>+</code>. <br>
        4. Multiplication / Division / Modulus: <code>*</code> <code>/</code> <code>%</code>. <br>
        5. Addition / Subtraction: <code>+</code> <code>-</code>.  <br>
        6. Relational operators <code><</code> <code>></code> <code>â‰¥</code> <code>=<</code>. <br>
        7. Logical operators: <code>&</code> <code>^</code> <code>|</code>. <br>
        8. Short-circuit logical operators: <code>||</code> <code>&&</code>. <br>
        9. Ternary operators: <code>: ?</code>. <br>
        10. Assignment operators: <code>=</code> <code>+=</code> <code>-=</code>. "},
    {category: "Operators and Statements",
    sub_category: "Working with Binary Arithmetic Operators",
    title: "Arithmetic Operators",
        content: "Multiplication operators have a higher order precedence than addition operators."},
    {category: "Operators and Statements",
    sub_category: "Working with Binary Arithmetic Operators",
    title: "Arithmetic Operators",
        content: "Modulus gives out the remainder of a division. "},
    {category: "Operators and Statements",
    sub_category: "Working with Binary Arithmetic Operators",
    title: "Numeric Promotion",
        content: "If two are from a different datatype, the smaller datatype gets promoted to the bigger datatype and the result is the bigger datatype."},
    {category: "Operators and Statements",
    sub_category: "Working with Binary Arithmetic Operators",
    title: "Numeric Promotion",
        content: "If one type is integral and the other double, Java converts the integral into a double."},
    {category: "Operators and Statements",
    sub_category: "Working with Binary Arithmetic Operators",
    title: "Numeric Promotion",
        content: "<code>short</code>,<code>byte</code> and <code>char</code> are always converted into an<code>int</code>."},
    {category: "Operators and Statements",
    sub_category: "Working with Binary Arithmetic Operators",
    title: "Numeric Promotion",
        content: "A<code>float</code> gets converted into a<code>double</code>."},
    {category: "Operators and Statements",
    sub_category: "Working with Binary Arithmetic Operators",
    title: "Numeric Promotion",
        content: "Unary operands are excluded from this rule."},
    {category: "Operators and Statements",
    sub_category: "Working with Unary Operators",
    title: "",
        content: "Unary operators require one variable expression or function."},
    {category: "Operators and Statements",
    sub_category: "Working with Unary Operators",
    title: "Logical Complement and Negation Operators",
        content: "<code>!</code> reverses a boolean, <code>-</code> makes a number negative."},
    {category: "Operators and Statements",
    sub_category: "Working with Unary Operators",
    title: "Increment and Decrement Operators",
        content: "Pre- returns the new value right away, post- returns the current value, but stores the new value in the variable."},
    {category: "Operators and Statements",
    sub_category: "Using Additional Binary Operators",
    title: "Assignment Operators",
        content: "Assignment operators assign what is on the right side of the operator to what is on the left side of the operator. Always keeping in mind that the datatypes are the same."},
    {category: "Operators and Statements",
    sub_category: "Using Additional Binary Operators",
    title: "Assignment Operators",
        content: "Java will automatically promote smaller to bigger datatypes. But not vice versa."},
    {category: "Operators and Statements",
    sub_category: "Using Additional Binary Operators",
    title: "Casting Primitive Values",
        content: "To assign bigger data types to smaller data types or floats/doubles to integers, we need to cast them by prepending the value with for example <code>(short)</code>, <code>(int)</code> etc..."},
    {category: "Operators and Statements",
    sub_category: "Using Additional Binary Operators",
    title: "Casting Primitive Values",
        content: "Overflow or underflow is when a value is too big for a datatype and the value wraps around the new lowest value."},
    {category: "Operators and Statements",
    sub_category: "Using Additional Binary Operators",
    title: "Compound Assignment Operators",
        content: "Assigns values and makes arithmetic operation to an already declared variable."},
    {category: "Operators and Statements",
    sub_category: "Using Additional Binary Operators",
    title: "Compound Assignment Operators",
        content: "The right hand side of an assignment can also be an expression."},
    {category: "Operators and Statements",
    sub_category: "Using Additional Binary Operators",
    title: "Compound Assignment Operators",
        content: "Casting is done automatically when necessary."},
    {category: "Operators and Statements",
    sub_category: "Using Additional Binary Operators",
    title: "Relational Operators",
        content: "Tell which operand is bigger or smaller."},
    {category: "Operators and Statements",
    sub_category: "Using Additional Binary Operators",
    title: "Relational Operators",
        content: "Return a boolean value."},
    {category: "Operators and Statements",
    sub_category: "Using Additional Binary Operators",
    title: "Logical Operators",
        content: "<code>&</code> AND - true if both operands are true."},
    {category: "Operators and Statements",
    sub_category: "Using Additional Binary Operators",
    title: "Logical Operators",
        content: "<code>|</code> Inclusive OR - true when at least one operand is true."},
    {category: "Operators and Statements",
    sub_category: "Using Additional Binary Operators",
    title: "Logical Operators",
        content: "<code>^</code> Exclusive OR - true if both operands are different."},
    {category: "Operators and Statements",
    sub_category: "Using Additional Binary Operators",
    title: "Logical Operators",
        content: "Short-circuit logical operators don't evaluate the second operand if the first one is conclusive."},
    {category: "Operators and Statements",
    sub_category: "Using Additional Binary Operators",
    title: "Equality Operators",
        content: "Two primitives can be checked for equality, their datatypes are being promoted."},
    {category: "Operators and Statements",
    sub_category: "Using Additional Binary Operators",
    title: "Equality Operators",
        content: "Two objects, including null and a String."},
    {category: "Operators and Statements",
    sub_category: "Using Additional Binary Operators",
    title: "Equality Operators",
        content: "Two boolean values."},
    {category: "Operators and Statements",
    sub_category: "Using Additional Binary Operators",
    title: "Equality Operators",
        content: "Object references can be equal if they point to the same place in memory."},
    {category: "Operators and Statements",
    sub_category: "Understanding Java Statements",
    title: "The <code>if-then</code> Statement",
        content: "<code>if(booleanExpression){}</code>."},
    {category: "Operators and Statements",
    sub_category: "Understanding Java Statements",
    title: "The <code>if-then</code> Statement",
        content: "Curly braces not required for the first line of code after the if statement."},
    {category: "Operators and Statements",
    sub_category: "Understanding Java Statements",
    title: "The <code>if-then-else</code> Statement",
        content: "<code>if(booleanExpression) {} else if{} else{}</code>."},
    {category: "Operators and Statements",
    sub_category: "Understanding Java Statements",
    title: "The <code>if-then-else</code> Statement",
        content: "Curly Braces required for block of multiple statements. Optional for single statement."},
    {category: "Operators and Statements",
    sub_category: "Understanding Java Statements",
    title: "The <code>if-then-else</code> Statement",
        content: "Order is important so that code is not unreachable."},
    {category: "Operators and Statements",
    sub_category: "Understanding Java Statements",
    title: "The <code>if-then-else</code> Statement",
        content: "<code>booleanExpression ? true : false</code>."},
    {category: "Operators and Statements",
    sub_category: "Understanding Java Statements",
    title: "The <code>if-then-else</code> Statement",
        content: "If you assign a ternary operator to a datatype, both outcomes must be in accordance with said datatype."},
    {category: "Operators and Statements",
    sub_category: "Understanding Java Statements",
    title: "The <code>if-then-else</code> Statement",
        content: "If you try to print it, the statements will be cast into strings."},
    {category: "Operators and Statements",
    sub_category: "Understanding Java Statements",
    title: "The <code>if-then-else</code> Statement",
        content: "The ternary operator short circuits if the true condition is met."},
    {category: "Operators and Statements",
    sub_category: "Understanding Java Statements",
    title: "The <code>switch</code> Statement",
        content: "<pre><code>switch(comparisonVariable){  
            case constantExpression:
                //stuff;
                break;
            default:
                //stuff;
                break;
         }</code></pre>"},
    {category: "Operators and Statements",
    sub_category: "Understanding Java Statements",
    title: "The <code>switch</code> Statement",
        content: "- Datatypes supported by switch statements: <br>
        - byte / Byte.<br>
        - short / Short.<br>
        - int / Integer.<br>
        - char / Character.<br>
        - String.<br>
        - enums."},
    {category: "Operators and Statements",
    sub_category: "Understanding Java Statements",
    title: "The <code>switch</code> Statement",
        content: "Case statements can only use literals, enum values or final constant variables."},
    {category: "Operators and Statements",
    sub_category: "Understanding Java Statements",
    title: "The <code>switch</code> Statement",
        content: "Datatypes can't mismatch."},
    {category: "Operators and Statements",
    sub_category: "Understanding Java Statements",
    title: "The <code>switch</code> Statement",
        content: "If there is no break statement, the code continues to the next case."},
    {category: "Operators and Statements",
    sub_category: "Understanding Java Statements",
    title: "The <code>while</code> Statement",
        content: "<code>while(nonConstantBoolean){}</code>."},
    {category: "Operators and Statements",
    sub_category: "Understanding Java Statements",
    title: "The <code>while</code> Statement",
        content: "Curly braces required for block of multiple statements. Optional for single statement."},
    {category: "Operators and Statements",
    sub_category: "Understanding Java Statements",
    title: "The <code>while</code> Statement",
        content: "Executes the code as long as the condition is true."},
    {category: "Operators and Statements",
    sub_category: "Understanding Java Statements",
    title: "The <code>do-while</code> Statement",
        content: "<code>do {} while(nonConstantBoolean)</code>."},
    {category: "Operators and Statements",
    sub_category: "Understanding Java Statements",
    title: "The <code>do-while</code> Statement",
        content: "Curly Braces required for block of multiple statements. Optional for single statement."},
    {category: "Operators and Statements",
    sub_category: "Understanding Java Statements",
    title: "The <code>do-while</code> Statement",
        content: "Just like while, the do-while loop executes the code at least once."},
    {category: "Operators and Statements",
    sub_category: "Understanding Java Statements",
    title: "The <code>for</code> Statement",
        content: "<code>for(initializatonStatement; booleanExpression; updateStatement) {}</code>."},
    {category: "Operators and Statements",
    sub_category: "Understanding Java Statements",
    title: "The <code>for</code> Statement",
        content: "<code>for(int x = 0; x > 9; x++){}</code>."},
    {category: "Operators and Statements",
    sub_category: "Understanding Java Statements",
    title: "The <code>for</code> Statement",
        content: "Can't reinitialize variables in initialization statement."},
    {category: "Operators and Statements",
    sub_category: "Understanding Java Statements",
    title: "The <code>for</code> Statement",
        content: "Can't declare different variable types in initialization statement."},
    {category: "Operators and Statements",
    sub_category: "Understanding Java Statements",
    title: "The <code>for</code> Statement",
        content: "All components are optional and if all are missing, infinite loop."},
    {category: "Operators and Statements",
    sub_category: "Understanding Java Statements",
    title: "The <code>for</code> Statement",
        content: "for-each <code>for(datatype instance : collection){instance}</code>."},
    {category: "Operators and Statements",
    sub_category: "Understanding Java Statements",
    title: "The <code>for</code> Statement",
        content: "Right-hand side is an iterable object, left hand side is a member of said object."},
    {category: "Operators and Statements",
    sub_category: "Understanding Advanced Flow Control",
    title: "Nested Loops",
        content: "Loops can contain loops."},
    {category: "Operators and Statements",
    sub_category: "Understanding Advanced Flow Control",
    title: "Adding Optional Labels",
        content: "A label is an optional pointer to the head of a statement that allows the application flow to, jump to, or break to it."},
    {category: "Operators and Statements",
    sub_category: "Understanding Advanced Flow Control",
    title: "Adding Optional Labels",
        content: "Same naming convention as variables except all uppercase letters followed by a colon."},
    {category: "Operators and Statements",
    sub_category: "Understanding Advanced Flow Control",
    title: "Adding Optional Labels",
        content: "They are useful in nested environments."},
    {category: "Operators and Statements",
    sub_category: "Understanding Advanced Flow Control",
    title: "The break Statement",
        content: "Exits the loop."},
    {category: "Operators and Statements",
    sub_category: "Understanding Advanced Flow Control",
    title: "The continue Statement",
        content: "Skips the rest of the body."}
])

puts "ðŸ˜ŠðŸ˜ŠðŸ˜ŠCreated: Operators and Statements"
puts "ðŸ¤”ðŸ¤”ðŸ¤”ðŸ¤”Creating: Core Java APIs"

Material.create!([
    {category: "Core Java APIs",
    sub_category: "Creating and manipulating Strings",
    title: "",
        content: "<code>String name = \"Fluffy\";</code>and <code>String name = new String(\"Fluffy\");</code>both create a string."},
    {category: "Core Java APIs",
    sub_category: "Creating and manipulating Strings",
    title: "",
        content: "The former creates it in the String Pool, whereas the latter creates a new String object."},
    {category: "Core Java APIs",
    sub_category: "Creating and manipulating Strings",
    title: "",
        content: "The String class is special and does not need to be instantiated with the keyword <code>new</code>"},
    {category: "Core Java APIs",
    sub_category: "Creating and manipulating Strings",
    title: "Concatenation",
        content: "Rules with the plus operator (+): <br>
        - If both operands are numeric, it performs addition. <br>
        - If one operand is numeric and the other a string, it performs concatenation. <br>
        - If both operand are strings, it performs concatenation. <br>
        - The expression is evaluated from left to right."},
    {category: "Core Java APIs",
    sub_category: "Creating and manipulating Strings",
    title: "Immutability",
        content: "Strings, once created can't be changed, they are immutable."},
    {category: "Core Java APIs",
    sub_category: "Creating and manipulating Strings",
    title: "Immutability",
        content: "One can't replace one character, or the size of it. It's packed optimally."},
    {category: "Core Java APIs",
    sub_category: "Creating and manipulating Strings",
    title: "Immutability",
        content: "You can reassign a change."},
    {category: "Core Java APIs",
    sub_category: "Creating and manipulating Strings",
    title: "The String Pool",
        content: "The string pool contains literal values that appear in the program."},
    {category: "Core Java APIs",
    sub_category: "Creating and manipulating Strings",
    title: "Important String Methods",
        content: "int: <code>length();</code>& <code>indexOf();</code>;"},
    {category: "Core Java APIs",
    sub_category: "Creating and manipulating Strings",
    title: "Important String Methods",
        content: "char: <code>charAt();</code>;"},
    {category: "Core Java APIs",
    sub_category: "Creating and manipulating Strings",
    title: "Important String Methods",
        content: "String: <code>substring();</code>, <code>toLowerCase();</code>, <code>toUpperCase();</code>, <code>replace();</code>, <code>concat();</code>& <code>trim();</code>;"},
    {category: "Core Java APIs",
    sub_category: "Creating and manipulating Strings",
    title: "Important String Methods",
        content: "boolean: <code>equals();</code>, <code>equalsIgnoreCase();</code>, <code>startsWith();</code>, <code>endsWith();</code>& <code>contains();</code>"},
    {category: "Core Java APIs",
    sub_category: "Creating and manipulating Strings",
    title: "Important String Methods",
        content: "Strings are a sequence of characters and Java indexes them at 0."},
    {category: "Core Java APIs",
    sub_category: "Creating and manipulating Strings",
    title: "Important String Methods",
        content: "<code>int length()</code>: Counts the number of characters in a string, it counts from 1 onward. Java only counts from 0 when indexing or positions in a list."},
    {category: "Core Java APIs",
    sub_category: "Creating and manipulating Strings",
    title: "Important String Methods",
        content: "<code>int indexOf()</code>: Lets you figure out the first Index of a matching character. Also of a matching string, and takes in the parameter form which string to start looking from. <br>
        - <code>int indexOf (int ch), (int ch, int fromIndex), (String str), (String str, int fromIndex);</code>"},
    {category: "Core Java APIs",
    sub_category: "Creating and manipulating Strings",
    title: "Important String Methods",
        content: "<code>char charAt()</code>: Lets you query the string to find out which character is at an index position. Counts form 0 and up."},
    {category: "Core Java APIs",
    sub_category: "Creating and manipulating Strings",
    title: "Important String Methods",
        content: "<code>String substring()</code>: Returns a string based on the input index. It starts at that index and finishes at the end, the second parameter is the index at which the sub-string should end. The substring begins at the specified beginIndex and extends to the character at index endIndex â€“ 1. Thus the length of the substring is endIndex-beginIndex. In other words you can say that beginIndex is inclusive and endIndex is exclusive while getting the substring. <br> 
        - An empty string is returned if both arguments are the same index number."},
    {category: "Core Java APIs",
    sub_category: "Creating and manipulating Strings",
    title: "Important String Methods",
        content: "<code>String toLowerCase()</code>& <code>String toUpperCase()</code>: Turns all lowercase characters to uppercase, and vice versa."},
    {category: "Core Java APIs",
    sub_category: "Creating and manipulating Strings",
    title: "Important String Methods",
        content: "<code>String replace()</code>: Search and replace of every matching character â‡’ <code>String replace(char oldChar, char newChar);</code>"},
    {category: "Core Java APIs",
    sub_category: "Creating and manipulating Strings",
    title: "Important String Methods",
        content: "<code>String trim()</code>: removes white space from beginning and end including <code>/t</code>, <code>/n</code>, and <code>/r</code>"},
    {category: "Core Java APIs",
    sub_category: "Creating and manipulating Strings",
    title: "Important String Methods",
        content: "<code>boolean equals()</code>& <code>boolean equalsIgnoreCase()</code>: Checks whether 2 String objects contain the same characters in the same order, and the <code>equalsIgnoreCase()</code>converts them if necessary."},
    {category: "Core Java APIs",
    sub_category: "Creating and manipulating Strings",
    title: "Important String Methods",
        content: "<code>boolean startsWith()</code>& <code>boolean endsWith()</code>: Checks case sensitive equality to the characters in the string."},
    {category: "Core Java APIs",
    sub_category: "Creating and manipulating Strings",
    title: "Important String Methods",
        content: "<code>boolean contains()</code>: looks for matches in the string, it can be anywhere in the String."},
    {category: "Core Java APIs",
    sub_category: "Creating and manipulating Strings",
    title: "Method Chaining",
        content: "Evaluates from left to right. It returns and gets picked up by the one on the right and so on."},
    {category: "Core Java APIs",
    sub_category: "Using the <code>StringBuilder</code> Class",
    title: "",
        content: "<code>StringBuilder</code>is mutable and it does not store interim strings to memory for efficiency purposes."},
    {category: "Core Java APIs",
    sub_category: "Using the <code>StringBuilder</code> Class",
    title: "Mutability and Chaining",
        content: "<code>StringBuilder</code>does not save itself into memory every time there is a change on it, instead it changes its own state and returns a reference to itself."},
    {category: "Core Java APIs",
    sub_category: "Using the <code>StringBuilder</code> Class",
    title: "Mutability and Chaining",
        content: "Pay attention to how many <code>StringBuilder sb = new StringBuilder(\"String\");</code>"},
    {category: "Core Java APIs",
    sub_category: "Using the <code>StringBuilder</code> Class",
    title: "Creating a <code>StringBuilder</code>",
        content: "<code>StringBuilder sb = new StringBuilder();.</code>"},
    {category: "Core Java APIs",
    sub_category: "Using the <code>StringBuilder</code> Class",
    title: "Creating a <code>StringBuilder</code>",
        content: "<code>StringBuilder sb = new StringBuilder();.</code>"},
    {category: "Core Java APIs",
    sub_category: "Using the <code>StringBuilder</code> Class",
    title: "Creating a <code>StringBuilder</code>",
        content: "<code>StringBuilder sb = new StringBuilder(\"banana\");.</code>"},
    {category: "Core Java APIs",
    sub_category: "Using the <code>StringBuilder</code> Class",
    title: "Important <code>StringBuilder</code> Methods",
        content: "int: <code>length();</code>, <code>indexOf();</code>;"},
    {category: "Core Java APIs",
    sub_category: "Using the <code>StringBuilder</code> Class",
    title: "Important <code>StringBuilder</code> Methods",
        content: "char: <code>charAt();</code>;"},
    {category: "Core Java APIs",
    sub_category: "Using the <code>StringBuilder</code> Class",
    title: "Important <code>StringBuilder</code> Methods",
        content: "String: <code>substring()</code>, <code>toString();</code>;"},
    {category: "Core Java APIs",
    sub_category: "Using the <code>StringBuilder</code> Class",
    title: "Important <code>StringBuilder</code> Methods",
        content: "StringBuilder: <code>append();</code>, <code>insert();</code>, <code>delete();</code>, <code>deleteCharAt();</code>, <code>reverse();</code>;"},
    {category: "Core Java APIs",
    sub_category: "Using the <code>StringBuilder</code> Class",
    title: "Important <code>StringBuilder</code> Methods",
        content: "<code>charAt(), indexOf(), length(), substring()</code><br>
        - <code>StringBuilder append(String str)</code> <br>
            - Not only strings but a lot of other datatypes. <br>
        - The same for StringBuilder as for String."},
    {category: "Core Java APIs",
    sub_category: "Using the <code>StringBuilder</code> Class",
    title: "Important <code>StringBuilder</code> Methods",
        content: "<code>StringBuilder insert(int offset, String str)</code> <br>
        - Pay attention that the indexes shift with every insert."},
    {category: "Core Java APIs",
    sub_category: "Using the <code>StringBuilder</code> Class",
    title: "Important <code>StringBuilder</code> Methods",
        content: "<code>StringBuilder delete(intÂ start, intÂ end);</code> and <code>StringBuilder deleteCharAt(intÂ index);</code> â‡’ <code>StringBuilder delete(int start, int end);</code>. <br>
        - Opposite of insert."},
    {category: "Core Java APIs",
    sub_category: "Using the <code>StringBuilder</code> Class",
    title: "Important <code>StringBuilder</code> Methods",
        content: "<code>StringBuilder reverse();</code>it reverses the string arrangement."},
    {category: "Core Java APIs",
    sub_category: "Using the <code>StringBuilder</code> Class",
    title: "Important <code>StringBuilder</code> Methods",
        content: "<code>String toString();</code>it converts a stringBuilder to a string."},
    {category: "Core Java APIs",
    sub_category: "Using the <code>StringBuilder</code> Class",
    title: "<code>StringBuilder</code> vs. <code>StringBuffer</code>",
        content: "They do the same thing, the former is faster."},
    {category: "Core Java APIs",
    sub_category: "Understanding Equality",
    title: "",
        content: "<code>==</code>compares object references to memory including the string pool."},
    {category: "Core Java APIs",
    sub_category: "Understanding Equality",
    title: "",
        content: "</code>equals</code>compares logical equality values, if an objects class doesn't have the <code>.equals()</code>, than java compares it's references."},
    {category: "Core Java APIs",
    sub_category: "Understanding Equality",
    title: "",
        content: "String has a logical equality method, StringBuilder does not."},
    {category: "Core Java APIs",
    sub_category: "Understanding Java Arrays",
    title: "",
        content: "<code>char[] letters</code>; letters is a reference variable, <code>char</code>is a primitive designating what datatypes go into the array and <code>[]</code>is a symbol for an array."},
    {category: "Core Java APIs",
    sub_category: "Understanding Java Arrays",
    title: "Creating an Array of Primitives",
        content: "<code>int[] numbers1 = new int[3];</code>- specifies the capacity."},
    {category: "Core Java APIs",
    sub_category: "Understanding Java Arrays",
    title: "Creating an Array of Primitives",
        content: "<code>int[] numbers2 = new int[] {42, 33, 32};</code>- specifies the capacity and the initial values. <br>
        - Shortcut <code>int[] numbers2 = {42, 33, 32};</code>"},
    {category: "Core Java APIs",
    sub_category: "Understanding Java Arrays",
    title: "Creating an Array of Primitives",
        content: "Legal ways: <code>int[] numAnimals;</code><code>int [] numAnimals;</code><code>int numAnimals[];</code> <code>int numAnimals [];</code>"},
    {category: "Core Java APIs",
    sub_category: "Understanding Java Arrays",
    title: "Creating an Array of Primitives",
        content: "<code>int [] ids, types;</code>- declares two arrays."},
    {category: "Core Java APIs",
    sub_category: "Understanding Java Arrays",
    title: "Creating an Array of Primitives",
        content: "<code>int ids[], types;</code>- declares one array and one integer."},
    {category: "Core Java APIs",
    sub_category: "Understanding Java Arrays",
    title: "Creating an Array with Reference Variables",
        content: "Arrays store reference variables to the objects in memory."},
    {category: "Core Java APIs",
    sub_category: "Understanding Java Arrays",
    title: "Creating an Array with Reference Variables",
        content: "An empty array stores default values for the datatypes it is declared for."},
    {category: "Core Java APIs",
    sub_category: "Understanding Java Arrays",
    title: "Creating an Array with Reference Variables",
        content: "Casting also works if you need to store a bigger datatype array into a smaller datatype array."},
    {category: "Core Java APIs",
    sub_category: "Understanding Java Arrays",
    title: "Using an Array",
        content: "Accessing an object in an array works through using it's index. <code>.length</code>gives us the max nr. of index + one and we don't want to get tricked by it."},
    {category: "Core Java APIs",
    sub_category: "Understanding Java Arrays",
    title: "Important Array Methods by return type:",
        content: "String: <code>java.util.Arrays.toString(array);</code>;"},
    {category: "Core Java APIs",
    sub_category: "Understanding Java Arrays",
    title: "Important Array Methods by return type:",
        content: "void: <code>java.util.Arrays.sort(array);</code>;"},
    {category: "Core Java APIs",
    sub_category: "Understanding Java Arrays",
    title: "Important Array Methods by return type:",
        content: "int: <code>java.util.Arrays.binarySearch(array, query);</code>& <code>.length</code>"},
    {category: "Core Java APIs",
    sub_category: "Understanding Java Arrays",
    title: "Sorting",
        content: "<code>Arrays.sort(Array);</code>"},
    {category: "Core Java APIs",
    sub_category: "Understanding Java Arrays",
    title: "Sorting",
        content: "You need to import java.util.Arrays or java.util.*."},
    {category: "Core Java APIs",
    sub_category: "Understanding Java Arrays",
    title: "Sorting",
        content: "Strings sort the first character alphabetically."},
    {category: "Core Java APIs",
    sub_category: "Understanding Java Arrays",
    title: "Searching",
        content: "<code>Arrays.searchBinary(Array);</code>"},
    {category: "Core Java APIs",
    sub_category: "Understanding Java Arrays",
    title: "Searching",
        content: "Array needs to be sorted to work, otherwise unpredictable."},
    {category: "Core Java APIs",
    sub_category: "Understanding Java Arrays",
    title: "Searching",
        content: "Searches for the index of a data."},
    {category: "Core Java APIs",
    sub_category: "Understanding Java Arrays",
    title: "Searching",
        content: "If non existent, it negates the proposed index value and subtracts one from it."},
    {category: "Core Java APIs",
    sub_category: "Understanding Java Arrays",
    title: "Varargs",
        content: "Variable arguments."},
    {category: "Core Java APIs",
    sub_category: "Understanding Java Arrays",
    title: "Varargs",
        content: "Use a variable defined using varargs as if it were a normal array."},
    {category: "Core Java APIs",
    sub_category: "Understanding Java Arrays",
    title: "Multidimensional Arrays",
        content: "Arrays can hold arrays as components which makes them multidimensional."},
    {category: "Core Java APIs",
    sub_category: "Understanding Java Arrays",
    title: "Creating a Multidimensional Array",
        content: "<code>int[][] vars1;</code>â‡’ 2D."},
    {category: "Core Java APIs",
    sub_category: "Understanding Java Arrays",
    title: "Creating a Multidimensional Array",
        content: "<code>int vars2 [][];</code>â‡’ 2D."},
    {category: "Core Java APIs",
    sub_category: "Understanding Java Arrays",
    title: "Creating a Multidimensional Array",
        content: "<code>int[] vars3 [];</code>â‡’ 2D."},
    {category: "Core Java APIs",
    sub_category: "Understanding Java Arrays",
    title: "Creating a Multidimensional Array",
        content: "<code>int[] vars3 [], space [][];</code>â‡’ 2D & 3D."},
    {category: "Core Java APIs",
    sub_category: "Understanding Java Arrays",
    title: "Creating a Multidimensional Array",
        content: "Size declaration â‡’ <code>String [][] rectangle = new String[3][2];</code>"},
    {category: "Core Java APIs",
    sub_category: "Understanding Java Arrays",
    title: "Creating a Multidimensional Array",
        content: "Asymmetrical content declaration â‡’ <code>int[][] differentSize = {{1,2}, {1}, {2,3,4,5}};</code>"},
    {category: "Core Java APIs",
    sub_category: "Understanding Java Arrays",
    title: "Using a Multidimensional Array",
        content: "Looping thought multidimensional arrays is most common."},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "",
        content: "An ArrayList can change the capacity as needed, as opposed to an Array."},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "",
        content: "You have to <code>import java.util.*;</code>"},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "",
        content: "Or import <code>java.util.ArrayList;</code>"},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Creating an <code>ArrayList</code>",
        content: "<code>Array list1 = new ArrayList();</code>- default nr. of slots."},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Creating an <code>ArrayList</code>",
        content: "<code>Array list2 = new ArrayList(10);</code>- specific nr. of slots."},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Creating an <code>ArrayList</code>",
        content: "<code>Array list3 = new ArrayList(list2);</code>- copy of the capacity and content of <code>list2</code>"},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Creating an <code>ArrayList</code>",
        content: "<code>ArrayList<String> list4 = new ArrayList<String>();</code>- Diamond operator specifies the datatype of the <code>ArrayList</code>content."},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Creating an <code>ArrayList</code>",
        content: "<code>ArrayList<String> list4 = new ArrayList<>();</code>- Can omit on the right side but need to keep <>."},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Creating an <code>ArrayList</code>",
        content: "<code>ArrayList</code>implements an interface called <code>List</code>"},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Creating an <code>ArrayList</code>",
        content: "Can store an <code>ArrayList</code>in a <code>List</code>reference but not vice versa."},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Important <code>ArrayList</code> methods by return type:",
        content: "boolean: <code>add(E element);</code>, <code>remove(Object object);</code>, <code>isEmpty();</code>, <code>contains(Object object);</code>& <code>equals(Object object);</code>;"},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Important <code>ArrayList</code> methods by return type:",
        content: "void: <code>add(int index, E element);</code>, <code>clear();</code>;"},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Important <code>ArrayList</code> methods by return type:",
        content: "E: <code>remove(int index);</code>, <code>set(int index, E newElement);</code>;"},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Important <code>ArrayList</code> methods by return type:",
        content: "int: <code>size();</code>"},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Using an <code>ArrayList</code>",
        content: "<code>E</code>- is used by convention in generics to mean \"any class that this array can hold\"."},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Using an <code>ArrayList</code>",
        content: "If I don't specify a type when creating an ArrayList, <code>E</code>means <code>Object</code>"},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Using an <code>ArrayList</code>",
        content: "<code>ArrayList</code>implements <code>toString()</code>"},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Using an <code>ArrayList</code>",
        content: "<code>add()</code>â‡’ <code>boolean add(E element); void add(int index, E element);</code>adds an element to the end of an array, if the <code>ArrayList</code>type isn't specified by a diamond operator generic, the types are all stored in object, object can hold all types except primitives. Add can also specify the index at which elements are added and I keep track of the shifting indexes. Also, if I add a type not equal to the generic I get a compiler error."},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Using an <code>ArrayList</code>",
        content: "<code>remove()</code>â‡’ <code>boolean remove(Object object); E remove(int index);</code>deletes the first matching value in the array or the value at the specified index. If it finds and removes a value, it prints true, if it doesn't find the value it prints false, if it finds the index it prints the removed value, if it doesn't find the index it throws and exception."},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Using an <code>ArrayList</code>",
        content: "<code>set()</code>â‡’ <code>E set(int index, E newElement);</code>replaces an element in an ArrayList."},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Using an <code>ArrayList</code>",
        content: "<code>isEmpty()</code>and <code>size()</code>â‡’ <code>boolean isEmpty(); int size();</code>former returns boolean, latter returns the size of the ArrayList."},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Using an <code>ArrayList</code>",
        content: "<code>clear()</code>â‡’ <code>void clear();</code>It deletes all the elements from the ArrayList and brings the <code>ArrayList.size() = 0</code>"},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Using an <code>ArrayList</code>",
        content: "<code>contains()</code> â‡’ <code>boolean contains(Object object);</code>It checks whether a certain value is present in the ArrayList and returns a boolean."},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Using an <code>ArrayList</code>",
        content: "<code>equals()</code>â‡’ <code>boolean equals(Object object)</code>Checks whether two ArrayLists have the same elements in the same order."},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Wrapper Classes",
        content: "For an <code>ArrayList</code>to accept a primitive, the primitive needs to be put within a corresponding wrapper class holding said primitive."},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Wrapper Classes",
        content: "boolean; Boolean; <code>new Boolean(true);</code>"},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Wrapper Classes",
        content: "byte; Byte; <code>new Byte((byte) 1);</code>"},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Wrapper Classes",
        content: "short; Short; <code>new Short((short) 1);</code>"},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Wrapper Classes",
        content: "int; Integer; <code>new Integer(1);</code>"},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Wrapper Classes",
        content: "long; Long; <code>new Long(1);</code>"},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Wrapper Classes",
        content: "float; Float; <code>new Float(1.0);</code>"},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Wrapper Classes",
        content: "double; Double; <code>new Double(1.0);</code>"},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Wrapper Classes",
        content: "char; Character; <code>new Character('a');</code>"},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Wrapper Classes",
        content: "<code>parse</code>methods return primitives and <code>valueOf</code>methods return wrappers."},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Wrapper Classes",
        content: "If the name of the primitive is in the method, it is returning that primitive."},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Wrapper Classes",
        content: "Boolean; <code>Boolean.parseBoolean(\"true\");</code><code>Boolean.valueOf(\"TRUE\");</code>"},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Wrapper Classes",
        content: "Byte; <code>Byte.parseByte(\"1\");</code><code>Byte.valueOf(\"2\");</code>"},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Wrapper Classes",
        content: "Short; <code>Short.parseShort(\"1\");</code><code>Short.valueOf(\"1\");</code>"},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Wrapper Classes",
        content: "Integer; <code>Integer.parsreInt(\"1\");</code><code>Integer.valueOf(\"2\");</code>"},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Wrapper Classes",
        content: "Long; <code>Long.parseLong(\"2\");</code><code>Long.valueOf(\"2\");</code>"},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Wrapper Classes",
        content: "Float; <code>Float.parseFloat(\"2\");</code><code>Float.valueOf(\"2.2\");</code>"},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Wrapper Classes",
        content: "Double; <code>Double.parseDouble(\"3\");</code><code>Double.valueOf(\"2.2\");</code>"},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Wrapper Classes",
        content: "Character; None; None;."},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Autoboxing",
        content: "Automatic conversion of primitives into Wrapper classes."},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Autoboxing",
        content: "Example: <code>List<Double> weights = new ArrayList<>();</code>"},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Autoboxing",
        content: "<code>weights.add(60.5); // [60.5]</code>â† it autoboxes the primitive 60.5 into a Double 60.5."},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Converting Between array and List",
        content: "List to array: <br>
        - <code>ArrayList.toArray(new String[0]);</code> <br>
        - The <code>0</code> tells Java to allocate as many spaces as there are in the <code>ArrayList</code>, a higher number makes more spaces."},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Converting Between array and List",
        content: "Array to List: <br>
        - The original array and the created array backed list are linked.  <br>
        - When a change is made to one it is available to the other. <br>
        - It is a fixed-size, array-backed list."},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Sorting",
        content: "Same as with arrays only different helper."},
    {category: "Core Java APIs",
    sub_category: "Understanding an <code>ArrayList</code>",
    title: "Sorting",
        content: "<code>Collections.sort(arrayList);</code>"},
    {category: "Core Java APIs",
    sub_category: "Working with Dates and Times",
    title: "",
        content: "<code>import java.time.*</code>"},
    {category: "Core Java APIs",
    sub_category: "Working with Dates and Times",
    title: "Creating Dates and Times",
        content: "<code>LocalDate â‡’ LocalDate.now();</code> <br>
        - <code>LocalDate date1 = LocalDate.of(2015, Month.JANUARY, 20) OR (2015, 1, 20);</code>"},
    {category: "Core Java APIs",
    sub_category: "Working with Dates and Times",
    title: "Creating Dates and Times",
        content: "<code>LocalTime â‡’ LocalTime.now();</code> <br>
        - <code>LocalTime time1 = LocalTime.of(6, 15, 19, 200);</code>"},
    {category: "Core Java APIs",
    sub_category: "Working with Dates and Times",
    title: "Creating Dates and Times",
        content: "<code>LocalDateTime â‡’ LocalDateTime.now();</code> <br>
        - <code>LocalDateTime.of(2015, 1, 20, 5, 15, 19, 200) OR (date1, time1);</code>"},
    {category: "Core Java APIs",
    sub_category: "Working with Dates and Times",
    title: "Creating Dates and Times",
        content: "<code>LocalDate d = new LocalDate();</code>â†’ Does not compile."},
    {category: "Core Java APIs",
    sub_category: "Working with Dates and Times",
    title: "Manipulating Dates and Times",
        content: "Date and Time classes are immutable."},
    {category: "Core Java APIs",
    sub_category: "Working with Dates and Times",
    title: "Manipulating Dates and Times",
        content: "<code>date.plusDays</code>, <code>plusMoths</code>, <code>plusYears</code>, <code>plusWeeks</code>also all in minus."},
    {category: "Core Java APIs",
    sub_category: "Working with Dates and Times",
    title: "Manipulating Dates and Times",
        content: "<code>time.plusHours</code>, <code>plusMinutes</code>, <code>plusSeconds</code>also all in minus."},
    {category: "Core Java APIs",
    sub_category: "Working with Dates and Times",
    title: "Working with Periods",
        content: "Adds an arbitrary period of time."},
    {category: "Core Java APIs",
    sub_category: "Working with Dates and Times",
    title: "Working with Periods",
        content: "<code>Period quarterly = Period.ofMonths(3);</code>"},
    {category: "Core Java APIs",
    sub_category: "Working with Dates and Times",
    title: "Working with Periods",
        content: "<code>DateTime.plus(period);</code>"},
    {category: "Core Java APIs",
    sub_category: "Working with Dates and Times",
    title: "Formatting Dates and Times",
        content: "Many methods like: <code>getDayOfWeek</code>, <code>getMonth</code>, <code>getYear</code>, <code>getDayOfYear</code>"},
    {category: "Core Java APIs",
    sub_category: "Working with Dates and Times",
    title: "Formatting Dates and Times",
        content: "<code>time.format(DateTimeFormatter.ISO_LOCAL_DATE));</code>"},
    {category: "Core Java APIs",
    sub_category: "Working with Dates and Times",
    title: "Formatting Dates and Times",
        content: "<code>DateTimeFormatter shortDate = DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT);</code><br>
        - <code>shortDate.format(dateTime);</code>â†’ 1/20/20."},
    {category: "Core Java APIs",
    sub_category: "Working with Dates and Times",
    title: "Formatting Dates and Times",
        content: "<code>DateTimeFormatter shortDateTime = DateTimeFormatter.ofLocalozedDateTime(FormatStyle.SHORT);</code><br>
        - <code>shortDateTime.format(dateTime);</code>â†’  1/20/20 11:12 AM."},
    {category: "Core Java APIs",
    sub_category: "Working with Dates and Times",
    title: "Formatting Dates and Times",
        content: "<code>DateTimeFormatter mediumDateTime= DateTimeFormatter.ofLocalozedDateTime(FormatStyle.MEDIUM;</code><br>
        - <code>mediumDateTime.format(dateTime);</code>â†’  Jan 20, 2020 11;12;34 AM"},
    {category: "Core Java APIs",
    sub_category: "Working with Dates and Times",
    title: "Formatting Dates and Times",
        content: "<code>DateTimeFormatter.ofPattern(\"MMM dd, yyy, hh:mm\");</code>"},
    {category: "Core Java APIs",
    sub_category: "Working with Dates and Times",
    title: "Parsing Dates and Times",
        content: "<code>DateTimeFormatter f = DateTimeFormatter.ofPattern(\"MM dd yyyy\");</code>"},
    {category: "Core Java APIs",
    sub_category: "Working with Dates and Times",
    title: "Parsing Dates and Times",
        content: "<code>LocalDate = LocalDate.parse(\"01 02 2015\", f);</code>â†’ 02 01 2020."}
])

puts "ðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜ŠCreated: Core Java APIs"
puts "ðŸ¤”ðŸ¤”ðŸ¤”ðŸ¤”ðŸ¤”ðŸ¤”Creating: Methods and Encapsulation"

Material.create!([
    {category: "Methods and Encapsulation",
    sub_category: "Designing Methods",
    title: "",
        content: "<code>public final void nap(int minutes) throws InterruptedException {};</code>"},
    {category: "Methods and Encapsulation",
    sub_category: "Designing Methods",
    title: "",
        content: "Access modifier â†’         <code>public</code> â†’ Not required."},
    {category: "Methods and Encapsulation",
    sub_category: "Designing Methods",
    title: "",
        content: "Optional specifier â†’      <code>final</code> â†’ Not required."},
    {category: "Methods and Encapsulation",
    sub_category: "Designing Methods",
    title: "",
        content: "Return type â†’             <code>void</code> â†’ Required."},
    {category: "Methods and Encapsulation",
    sub_category: "Designing Methods",
    title: "",
        content: "Method name â†’             <code>nap</code> â†’ Required."},
    {category: "Methods and Encapsulation",
    sub_category: "Designing Methods",
    title: "",
        content: "Parameter list â†’          <code>(int minutes)</code> â†’ Required, can be empty parentheses."},
    {category: "Methods and Encapsulation",
    sub_category: "Designing Methods",
    title: "",
        content: "Optional exception list â†’ <code>throws InterruptedException</code> â†’ not Required."},
    {category: "Methods and Encapsulation",
    sub_category: "Designing Methods",
    title: "",
        content: "Method body â†’             <code>{}</code> â†’ Required, but can be empty braces."},
    {category: "Methods and Encapsulation",
    sub_category: "Designing Methods",
    title: "Access Modifiers",
        content: "<code>private</code> â†’ The method can only be called from within the same class."},
    {category: "Methods and Encapsulation",
    sub_category: "Designing Methods",
    title: "Access Modifiers",
        content: "<i>Default (Package Private) Access â†’</i> The method can only be called from classes in the same package. No keyword for default access. Omit the access modifier."},
    {category: "Methods and Encapsulation",
    sub_category: "Designing Methods",
    title: "Access Modifiers",
        content: "<code>protected</code> â†’ The method can only be called from classes in the same package or subclasses."},
    {category: "Methods and Encapsulation",
    sub_category: "Designing Methods",
    title: "Access Modifiers",
        content: "<code>public</code> â†’ The method can be called from any class."},
    {category: "Methods and Encapsulation",
    sub_category: "Designing Methods",
    title: "Access Modifiers",
        content: "Must be specified before the return type."},
    {category: "Methods and Encapsulation",
    sub_category: "Designing Methods",
    title: "Access Modifiers",
        content: "Only one is permitted."},
    {category: "Methods and Encapsulation",
    sub_category: "Designing Methods",
    title: "Optional Specifiers",
        content: "Multiple or none."},
    {category: "Methods and Encapsulation",
    sub_category: "Designing Methods",
    title: "Optional Specifiers",
        content: "<code>static</code> â†’ Used for class methods."},
    {category: "Methods and Encapsulation",
    sub_category: "Designing Methods",
    title: "Optional Specifiers",
        content: "<code>abstract</code> â†’ Used when not providing a method body."},
    {category: "Methods and Encapsulation",
    sub_category: "Designing Methods",
    title: "Optional Specifiers",
        content: "<code>synchronized</code> â†’ On the OCP."},
    {category: "Methods and Encapsulation",
    sub_category: "Designing Methods",
    title: "Optional Specifiers",
        content: "<code>native</code> â†’ Not on OCA or OCP. Used when interacting with code written in a different language such as C++."},
    {category: "Methods and Encapsulation",
    sub_category: "Designing Methods",
    title: "Optional Specifiers",
        content: "<code>strictfp</code> â†’ Not on OCA or OCP. Used for making floating-point calculations portable."},
    {category: "Methods and Encapsulation",
    sub_category: "Designing Methods",
    title: "Return Type",
        content: "Can be a Java type or void."},
    {category: "Methods and Encapsulation",
    sub_category: "Designing Methods",
    title: "Return Type",
        content: "The body must have a return statement returning a matching primitive or object type."},
    {category: "Methods and Encapsulation",
    sub_category: "Designing Methods",
    title: "Return Type",
        content: "If void, a return can be omitted or a return statement with no value."},
    {category: "Methods and Encapsulation",
    sub_category: "Designing Methods",
    title: "Return Type",
        content: "All possible branches need to return the return type."},
    {category: "Methods and Encapsulation",
    sub_category: "Designing Methods",
    title: "Return Type",
        content: "When returning a value, it needs to be assignable to the return type."},
    {category: "Methods and Encapsulation",
    sub_category: "Designing Methods",
    title: "Method Name",
        content: "Same naming convention as variables."},
    {category: "Methods and Encapsulation",
    sub_category: "Designing Methods",
    title: "Method Name",
        content: "Can't start with a number, _, $, Upper and lower case letters are allowed, reserved words are not."},
    {category: "Methods and Encapsulation",
    sub_category: "Designing Methods",
    title: "Parameter List",
        content: "Can be empty parenthesis."},
    {category: "Methods and Encapsulation",
    sub_category: "Designing Methods",
    title: "Parameter List",
        content: "Must be separated by comma."},
    {category: "Methods and Encapsulation",
    sub_category: "Designing Methods",
    title: "Optional Exception List",
        content: "<code>throws</code> as many as I like, separated by a comma <code>{}</code>."},
    {category: "Methods and Encapsulation",
    sub_category: "Designing Methods",
    title: "Method Body",
        content: "It's a code block."},
    {category: "Methods and Encapsulation",
    sub_category: "Working with Varargs",
    title: "",
        content: "The vararg must be the last element in a method's parameter list."},
    {category: "Methods and Encapsulation",
    sub_category: "Working with Varargs",
    title: "",
        content: "Only one vararg per method."},
    {category: "Methods and Encapsulation",
    sub_category: "Working with Varargs",
    title: "",
        content: "When calling a method with vararg parameter, you can pass in an array, or pass in the elements of an array and let java create the array."},
    {category: "Methods and Encapsulation",
    sub_category: "Working with Varargs",
    title: "",
        content: "If I omit vararg value, java creates an array with length = 0."},
    {category: "Methods and Encapsulation",
    sub_category: "Working with Varargs",
    title: "",
        content: "Null is also passable and java treats it like an array reference that happens to be null."},
    {category: "Methods and Encapsulation",
    sub_category: "Applying Access Modifiers",
    title: "",
        content: "From most restrictive to least restrictive: <br>
        1. <code>private</code>; <br>
        2. <i>Default (Package Private) Access</i>; <br>
        3. <code>protected</code>; <br>
        4. <code>public</code>."},
    {category: "Methods and Encapsulation",
    sub_category: "Applying Access Modifiers",
    title: "Private Access",
        content: "Only code in the same class can call private methods or access private fields."},
    {category: "Methods and Encapsulation",
    sub_category: "Applying Access Modifiers",
    title: "Default (Package Private) Access",
        content: "Only code from classes in the same package can call methods or access fields."},
    {category: "Methods and Encapsulation",
    sub_category: "Applying Access Modifiers",
    title: "Protected Access",
        content: "Allows everything the default (package private) access allows and adds the access by members of a child class."},
    {category: "Methods and Encapsulation",
    sub_category: "Applying Access Modifiers",
    title: "Public Access",
        content: "Member can be accessed form anywhere."},
    {category: "Methods and Encapsulation",
    sub_category: "Applying Access Modifiers",
    title: "Designing Static Methods and Fields",
        content: "Static methods don't require an instance of the class."},
    {category: "Methods and Encapsulation",
    sub_category: "Applying Access Modifiers",
    title: "Designing Static Methods and Fields",
        content: "Static methods are a member of the single class object and is independent of any instances of that class."},
    {category: "Methods and Encapsulation",
    sub_category: "Applying Access Modifiers",
    title: "Designing Static Methods and Fields",
        content: "You can call the static methods by the class name."},
    {category: "Methods and Encapsulation",
    sub_category: "Applying Access Modifiers",
    title: "Designing Static Methods and Fields",
        content: "It eliminates for a caller to instantiate an object just to call the method."},
    {category: "Methods and Encapsulation",
    sub_category: "Applying Access Modifiers",
    title: "Designing Static Methods and Fields",
        content: "For a state that is shared by all instances of a class, like a counter."},
    {category: "Methods and Encapsulation",
    sub_category: "Applying Access Modifiers",
    title: "Calling a Static Variable or Method",
        content: "Put the class name before the method or variable."},
    {category: "Methods and Encapsulation",
    sub_category: "Applying Access Modifiers",
    title: "Static vs. Instance",
        content: "A static method can only call a static method or a static variable. Because static does not require an object to be instantiated."},
    {category: "Methods and Encapsulation",
    sub_category: "Applying Access Modifiers",
    title: "Static vs. Instance",
        content: "An instance method can call a static method / variable and an instance method / variable."},
    {category: "Methods and Encapsulation",
    sub_category: "Applying Access Modifiers",
    title: "Static Variables",
        content: "Some static variables are meant to change, for example counters. <br>
        - <code>private static int counter = 0;</code>."},
    {category: "Methods and Encapsulation",
    sub_category: "Applying Access Modifiers",
    title: "Static Variables",
        content: "Other static variables are never meant to change. We add the <code>final</code> keyword to it."},
    {category: "Methods and Encapsulation",
    sub_category: "Applying Access Modifiers",
    title: "Static Variables",
        content: "It is known as a constant and the naming convention is all uppercase and separated by underscore. <br>
        - <code>private static final int NUM_BUCKETS = 45;</code>"},
    {category: "Methods and Encapsulation",
    sub_category: "Applying Access Modifiers",
    title: "Static Initialization",
        content: "Run when the class is first used."},
    {category: "Methods and Encapsulation",
    sub_category: "Applying Access Modifiers",
    title: "Static Imports",
        content: "Imports for static members of other classes."},
    {category: "Methods and Encapsulation",
    sub_category: "Passing Data Among Methods",
    title: "",
        content: "Java is a \"pass-by-value\" language. A copy of a variable is made and the method receives that copy. Assignments made in the method don't affect the caller."},
    {category: "Methods and Encapsulation",
    sub_category: "Overloading Methods",
    title: "",
        content: "When there are different method signatures with the same name but different type parameters."},
    {category: "Methods and Encapsulation",
    sub_category: "Overloading Methods",
    title: "",
        content: "Different type, more types, same types in different order."},
    {category: "Methods and Encapsulation",
    sub_category: "Overloading Methods",
    title: "",
        content: "Access modifier, return type and exception list are irrelevant to overloading."},
    {category: "Methods and Encapsulation",
    sub_category: "Overloading Methods",
    title: "",
        content: "Vararg and array produce a compilation error."},
    {category: "Methods and Encapsulation",
    sub_category: "Overloading Methods",
    title: "",
        content: "Java autoboxes primitives into objects once."},
    {category: "Methods and Encapsulation",
    sub_category: "Overloading Methods",
    title: "",
        content: "Java matches the more specific type first."},
    {category: "Methods and Encapsulation",
    sub_category: "Creating Constructors",
    title: "",
        content: "Special method that matches the Class name and has no return type."},
    {category: "Methods and Encapsulation",
    sub_category: "Creating Constructors",
    title: "",
        content: "Constructor are used when creating a new object. This is called instantiation because it creates a new instance of the class."},
    {category: "Methods and Encapsulation",
    sub_category: "Creating Constructors",
    title: "",
        content: "A constructor is called when we write the keyword <code>new</code> followed by the name of the class we want to instantiate."},
    {category: "Methods and Encapsulation",
    sub_category: "Creating Constructors",
    title: "",
        content: "The optional <code>this</code> keyword tells Java that I want to reference an instance variable. <br>
        - Necessary when an instance variable has the same name as a method parameter."},
    {category: "Methods and Encapsulation",
    sub_category: "Creating Constructors",
    title: "Default Constructor",
        content: "Every class has a constructor and Java creates one without parameters if none coded."},
    {category: "Methods and Encapsulation",
    sub_category: "Creating Constructors",
    title: "Default Constructor",
        content: "<code>private</code> constructors don't compile at instantiation because they are inaccessible. So a <code>private</code> constructor tells Java not to generate a no-arguments default constructor. This is useful when a class only has static methods or the class wants to control all calls to create new instances of itself."},
    {category: "Methods and Encapsulation",
    sub_category: "Creating Constructors",
    title: "Overloading Constructors",
        content: "The names must match since they are the same as the class name."},
    {category: "Methods and Encapsulation",
    sub_category: "Creating Constructors",
    title: "Overloading Constructors",
        content: "The parameter list must be different."},
    {category: "Methods and Encapsulation",
    sub_category: "Creating Constructors",
    title: "Overloading Constructors",
        content: "When <code>this()</code> is used as if it were a method, Java calls another constructor on the same instance of the class."},
    {category: "Methods and Encapsulation",
    sub_category: "Creating Constructors",
    title: "Overloading Constructors",
        content: "Example: <code>public Hamster(int weight) { this(weight, \"brown\");}</code>."},
    {category: "Methods and Encapsulation",
    sub_category: "Creating Constructors",
    title: "Final Fields",
        content: "The constructor is allowed to assign final instance variables in it. By the time the constructor completes, all final instance variables must have been set."},
    {category: "Methods and Encapsulation",
    sub_category: "Creating Constructors",
    title: "Order of Initialization",
        content: "Four rules: <br>
        1. If there is a superclass, initialize it first. <br>
        2. Static variable declarations and static initializers in the order they appear in the file. <br>
        3. Instance variable declarations and instance initializes in the order they appear in the file. <br>
        4. The constructor."},
    {category: "Methods and Encapsulation",
    sub_category: "Encapsulating Data",
    title: "",
        content: "To make accessing or changing data in other classes more orderly, we write getter or setter methods with some validation attached to them."},
    {category: "Methods and Encapsulation",
    sub_category: "Encapsulating Data",
    title: "",
        content: "JavaBeans is a naming convention and goes as follows: <br>
        - Properties are private â†’ <code>private int numEggs;</code>. <br>
        - Getter methods begin with <code>is</code> if the property is a boolean â‡’ <code>public boolean isHappy() {return happy};</code>. <br>
        - Getter methods begin with <code>get</code> if the property is not a boolean. â†’ <code>public int getNumEggs() {return numEggs;}</code>. <br>
        - Setter methods begin with set â†’ <code>public void setHappy(boolean happy) {this.happy + happy;}</code>. <br>
        - The method name must have a prefix of set/get/is, followed by the first letter if the property in uppercase, followed by the rest of the property name."},
    {category: "Methods and Encapsulation",
    sub_category: "Encapsulating Data",
    title: "Creating Immutable Classes",
        content: "If you don't have a setter, the class becomes immutable."},
    {category: "Methods and Encapsulation",
    sub_category: "Encapsulating Data",
    title: "Creating Immutable Classes",
        content: "If you want to change the initial value of an instance, you put the field you want to set in the constructor."},
    {category: "Methods and Encapsulation",
    sub_category: "Writing Simple Lambdas",
    title: "",
        content: "Functional programming is writing code more declaratively."},
    {category: "Methods and Encapsulation",
    sub_category: "Writing Simple Lambdas",
    title: "",
        content: "You specify what you want to do rather than dealing with the state of the object."},
    {category: "Methods and Encapsulation",
    sub_category: "Writing Simple Lambdas",
    title: "",
        content: "Lambda expressions is a block of code that gets passed around."},
    {category: "Methods and Encapsulation",
    sub_category: "Writing Simple Lambdas",
    title: "",
        content: "As an anonymous method."},
    {category: "Methods and Encapsulation",
    sub_category: "Writing Simple Lambdas",
    title: "Lambda Example",
        content: "There's an example in the book."},
    {category: "Methods and Encapsulation",
    sub_category: "Writing Simple Lambdas",
    title: "Lambda Syntax",
        content: "<code>a â†’ a.canHop()</code>."},
    {category: "Methods and Encapsulation",
    sub_category: "Writing Simple Lambdas",
    title: "Lambda Syntax",
        content: "<code>a</code> is the parameter name, the arrow operator separates the parameter from the body and <code>a.canHop()</code> is the body."}
])

puts "ðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜ŠCreated: Methods and Encapsulation"
puts "ðŸ¤”ðŸ¤”ðŸ¤”ðŸ¤”ðŸ¤”ðŸ¤”ðŸ¤”ðŸ¤”Creating: Class Design"

Material.create!([
    {category: "Class Design",
    sub_category: "Introducing Class Inheritance",
    title: "",
        content: "Inheritance is the process by which a new child subclass automatically includes any <code>public</code> or <code>protected</code> primitives, objects, or methods defined in the parent class."},
    {category: "Class Design",
    sub_category: "Introducing Class Inheritance",
    title: "",
        content: "Only single inheritance is possible and multiple children are permitted."},
    {category: "Class Design",
    sub_category: "Introducing Class Inheritance",
    title: "",
        content: "To prevent a class being extended, mark the class with the <code>final</code> modifier."},
    {category: "Class Design",
    sub_category: "Extending a Class",
    title: "",
        content: "You can extend a class by adding the parent class name in the definition using the <code>extends</code> keyword."},
    {category: "Class Design",
    sub_category: "Extending a Class",
    title: "",
        content: "Syntax: <br>
        <br>
        <code>public abstract class ElephantSeal extends Seal { }</code><br>
        <br>
        - <code>public</code> or <i>default (package private)</i> access modifier.<br>
        - <code>abstract</code> or <code>final</code> keyword (optional).<br>
        - <code>class</code> keyword (required).<br>
        - <code>ElephantSeal</code> class name (required).<br>
        - <code>extends Seal</code> extends parent class (optional).<br>
        - <code>{}</code> braces can be empty (required)."},
    {category: "Class Design",
    sub_category: "Extending a Class",
    title: "",
        content: "If two classes are in the same package, an import statement is not required to extend a class from one file into another file."},
    {category: "Class Design",
    sub_category: "Extending a Class",
    title: "",
        content: "<code>private</code> variables from a parent can't be accessed in a child by extending the parent."},
    {category: "Class Design",
    sub_category: "Extending a Class",
    title: "",
        content: "Child-classes are bigger in the sense that they have their own members together with the inherited members."},
    {category: "Class Design",
    sub_category: "Extending a Class",
    title: "",
        content: "Child-classes are more explicit than the parent classes."},
    {category: "Class Design",
    sub_category: "Applying Class Access Modifiers",
    title: "",
        content: "Only <code>public</code> and <i>default (package private)</i> access modifiers on classes are on the OCA. <br>
        - <code>public</code> access - a class can be referenced and used in any other class.<br>
        - <i>default (package private)</i> access - a lack of access modifier keyword indicates that a class can only be accessed by a class within the same package."},
    {category: "Class Design",
    sub_category: "Applying Class Access Modifiers",
    title: "",
        content: "If only one or none classes have <code>public</code> access modifier, can there be one or more classes in a file."},
    {category: "Class Design",
    sub_category: "Applying Class Access Modifiers",
    title: "",
        content: "Same rules apply for interfaces."},
    {category: "Class Design",
    sub_category: "Creating Java Objects",
    title: "",
        content: "All classes in Java inherit form a single object <code>java.lang.Object</code>."},
    {category: "Class Design",
    sub_category: "Creating Java Objects",
    title: "",
        content: "<code>java.lang.Object</code> is the only class in Java that doesn't have any parent classes."},
    {category: "Class Design",
    sub_category: "Creating Java Objects",
    title: "",
        content: "The compiler automatically inserts inheritance code about <code>java.lang.Object</code> into any class, which doesn't extend a specific class."},
    {category: "Class Design",
    sub_category: "Creating Java Objects",
    title: "",
        content: "If I define a new class that extends an existing class, Java doesn't add this syntax."},
    {category: "Class Design",
    sub_category: "Creating Java Objects",
    title: "",
        content: "On top of the inheritance structure, there is always <code>java.lang.Object</code>."},
    {category: "Class Design",
    sub_category: "Defining Constructors",
    title: "",
        content: "A class can have one or more."},
    {category: "Class Design",
    sub_category: "Defining Constructors",
    title: "",
        content: "If there is no constructor in a class, Java inserts a no-argument constructor."},
    {category: "Class Design",
    sub_category: "Defining Constructors",
    title: "",
        content: "The first statement of every constructor in Java is either a call to another constructor within the class, using <code>this()</code>, or a call to a constructor in the direct parent class, using <code>super()</code>."},
    {category: "Class Design",
    sub_category: "Defining Constructors",
    title: "",
        content: "If a parent constructor takes arguments, the <code>super()</code> call in the child constructor must also take arguments."},
    {category: "Class Design",
    sub_category: "Defining Constructors",
    title: "",
        content: "<code>super()</code> and <code>this()</code> have to be on the first line in the constructor, otherwise it won't compile. No duplicates are allowed."},
    {category: "Class Design",
    sub_category: "Defining Constructors",
    title: "",
        content: "If the parent has more than one constructor, the child may use any valid parent constructor in its definition, as long as the appropriate input parameters to the parent constructor are provided."},
    {category: "Class Design",
    sub_category: "Defining Constructors",
    title: "Understanding Compiler Enhancements",
        content: "Java automatically inserts a call to the no-argument constructor <code>super()</code> if the first statement is not a call to the parent constructor. <br>
        <br>
        <pre><code>
        Step 1:
        public class Donkey {
        }      

        Step 2:       
        public class Dokney {
            public Donkey(){
            }
        }

        Step 3:
        public class Dokney {
            public Donkey(){
                super();
            }
        }</code></pre>"},
    {category: "Class Design",
    sub_category: "Defining Constructors",
    title: "Understanding Compiler Enhancements",
        content: "If a parent has a constructor with a parameter list, and the child has no constructor, the code will not compile."},
    {category: "Class Design",
    sub_category: "Defining Constructors",
    title: "Understanding Compiler Enhancements",
        content: "The compiler will insert a no-argument constructor, but without a proper parameter list, which maps onto the parent constructor's parameter list, the code won't compile."},
    {category: "Class Design",
    sub_category: "Defining Constructors",
    title: "Understanding Compiler Enhancements",
        content: "Constructor Definition Rules: <br>
        1. The first statement of every constructor is a call to another constructor within the class using <code>this()</code>, or a call to a constructor in the direct parent class using <code>super()</code>.<br>
        2. The <code>super()</code> call may not be used after the first statement of the constructor.<br>
        3. If no <code>super()</code> call is declared in a constructor, Java will insert a <code>super()</code> as the first statement of the constructor.<br>
        4. If the parent doesn't have a no-argument constructor and the child doesn't define any constructors, the compiler will throw an error and try to insert a default no-argument constructor into the child class.<br>
        5. If the parent doesn't have a no-argument constructor, the compiler requires an explicit call to a parent constructor in each child constructor."},
    {category: "Class Design",
    sub_category: "Defining Constructors",
    title: "Calling Constructors",
        content: "The parent constructor is always executed before the child constructor."},
    {category: "Class Design",
    sub_category: "Defining Constructors",
    title: "Calling Constructors",
        content: "\"Think like the compiler\"."},
    {category: "Class Design",
    sub_category: "Calling Inherited Class Members",
    title: "",
        content: "Java classes may use any <code>public</code> or <code>protected</code> members of the parent class, including methods, primitives, or object references."},
    {category: "Class Design",
    sub_category: "Calling Inherited Class Members",
    title: "",
        content: "If the parent and the child are part of the same package, the child may use any <i>default</i> member of the parent."},
    {category: "Class Design",
    sub_category: "Calling Inherited Class Members",
    title: "",
        content: "A child may never access a <code>private</code> member of a parent directly, only indirectly via getter methods."},
    {category: "Class Design",
    sub_category: "Calling Inherited Class Members",
    title: "",
        content: "To reference a member in a parent, just call it directly. Example: <code>methodName()</code>, <code>primitiveReferenceVariable</code>."},
    {category: "Class Design",
    sub_category: "Calling Inherited Class Members",
    title: "",
        content: "The keyword <code>this</code> is used to access a member of the current class, but also of the parent class, since the child inherits all the members of the parent."},
    {category: "Class Design",
    sub_category: "Calling Inherited Class Members",
    title: "",
        content: "The keyword <code>super</code> can be used to specifically call a member from the parent class. It can't be used to call a member of the current class."},
    {category: "Class Design",
    sub_category: "Calling Inherited Class Members",
    title: "",
        content: "<code>super()</code> calls the parent constructor, <code>super</code> as in <code>super.parentMember()</code>, references a parent member."},
    {category: "Class Design",
    sub_category: "Inheriting Methods",
    title: "Overriding a Method",
        content: "If I want to define a new version of a method in the child, from an existing method in the parent, I can override the method by declaring a new method with the same signature and return type as the method in the parent."},
    {category: "Class Design",
    sub_category: "Inheriting Methods",
    title: "Overriding a Method",
        content: "I may reference the parent version of the method with the <code>super</code> keyword or the child-method with the <code>this</code> keyword."},
    {category: "Class Design",
    sub_category: "Inheriting Methods",
    title: "Overriding a Method",
        content: "The compiler performs the following checks when you override a non-private method: <br>
        1. The child-method must have the same signature (the name and list of input parameters) as the parent-method.<br>
        2. The child-method must be at least as accessible or more accessible than the parent-method.<br>
        3. The child-method may not throw a checked exception that is new or broader than the class of any exception thrown by the parent-method.<br>
        4. If the child-method returns a value, it must be the same or a subclass of the parent-method return value, known as <i>covariant return types</i>."},
    {category: "Class Design",
    sub_category: "Inheriting Methods",
    title: "Overriding a Method",
        content: "If two methods have the same name but different signatures, the methods are overloaded."},
    {category: "Class Design",
    sub_category: "Inheriting Methods",
    title: "Overriding a Method",
        content: "Overloaded and overridden methods are the same because they use the same method name, the former has a different set of parameters, the latter has the same set of parameters."},
    {category: "Class Design",
    sub_category: "Inheriting Methods",
    title: "Overriding a Method",
        content: "If the overridden methods return type in not a covariant return type, the code doesn't compile."},
    {category: "Class Design",
    sub_category: "Inheriting Methods",
    title: "Overriding a Method",
        content: "The child exceptions need to be more specific than the parent exceptions."},
    {category: "Class Design",
    sub_category: "Inheriting Methods",
    title: "Overriding a Method",
        content: "A child can't invent a checked exception without the parent. A child can't define a new checked exception the parent did not define."},
    {category: "Class Design",
    sub_category: "Inheriting Methods",
    title: "Overriding a Method",
        content: "Any time I see a method being overridden, first check to make sure it is truly being overridden and not overloaded. If overridden, check the access modifiers, return types and exceptions defined."},
    {category: "Class Design",
    sub_category: "Inheriting Methods",
    title: "Re-declaring <code>private</code> Methods",
        content: "Since <code>private</code> methods are not accessible outside of the class they are declared in, it is impossible to override or overload them."},
    {category: "Class Design",
    sub_category: "Inheriting Methods",
    title: "Re-declaring <code>private</code> Methods",
        content: "The child therefore redefines / re-declares the <code>private</code> parent-method."},
    {category: "Class Design",
    sub_category: "Inheriting Methods",
    title: "Hiding Static Methods",
        content: "A <i>hidden method</i> occurs when a child class defines a static method with the same name and signature as a static method defined in a parent class."},
    {category: "Class Design",
    sub_category: "Inheriting Methods",
    title: "Hiding Static Methods",
        content: "Method hiding is similar but not exactly the same as method overriding."},
    {category: "Class Design",
    sub_category: "Inheriting Methods",
    title: "Hiding Static Methods",
        content: "All the rules as overriding apply, only one rule is added: the usage of the <code>static</code> keyword must be the same between parent and child classes."},
    {category: "Class Design",
    sub_category: "Inheriting Methods",
    title: "Hiding Static Methods",
        content: "The compiler performs the following checks when you override a <code>static</code> non-private method: <br>
        1. SAME NAME AND PARAMETERS: The child-method must have the same signature (the name and list of input parameters) as the parent-method.<br>
        2. MORE ACCESSABILLITY: The child-method must be at least as accessible or more accessible than the parent-method.<br>
        3. SUB TYPE EXCEPTIONS: The child-method may not throw a checked exception that is new or broader than the class of any exception thrown by the parent-method.<br>
        4. SUB TYPE RETURN: If the child-method returns a value, it must be the same or a subclass of the parent-method return value, known as <i>covariant return types</i>.<br>
        5. SAME STATIC: The child-method must be marked as <code>static</code> if it is marked as <code>static</code> in the parent class. Likewise, the child-method must not be marked as <code>static</code>, if it is not marked as <code>static</code> in the parent class."},
    {category: "Class Design",
    sub_category: "Inheriting Methods",
    title: "Overriding vs. Hiding Methods",
        content: "Unlike overriding a method, in which a child method replaces the parent method in calls defined in both the parent and the child, hidden methods only replace parent methods in the calls defined in the child class."},
    {category: "Class Design",
    sub_category: "Inheriting Methods",
    title: "Overriding vs. Hiding Methods",
        content: "At runtime, the child version of an overridden method is always executed for an instance regardless of whether the method call is defined in a parent or child class method."},
    {category: "Class Design",
    sub_category: "Inheriting Methods",
    title: "Overriding vs. Hiding Methods",
        content: "In this manner, a parent method is never used unless an explicit call to the parent method is referenced, using the syntax <code>super.method()</code>."},
    {category: "Class Design",
    sub_category: "Inheriting Methods",
    title: "Overriding vs. Hiding Methods",
        content: "Alternatively, at runtime, the parent version of a hidden method is always executed if the call to the method is defined in the parent class."},
    {category: "Class Design",
    sub_category: "Inheriting Methods",
    title: "Creating <code>final</code> methods",
        content: "<code>final</code> methods can't be overridden."},
    {category: "Class Design",
    sub_category: "Inheriting Methods",
    title: "Creating <code>final</code> methods",
        content: "A child class is forbidden to override or hide a <code>final</code> method."},
    {category: "Class Design",
    sub_category: "Inheriting Methods",
    title: "Creating <code>final</code> methods",
        content: "You cannot hide a static method in a parent class if it is marked as <code>final</code>."},
    {category: "Class Design",
    sub_category: "Inheriting Variables",
    title: "",
        content: "Java doesn't allow variables to be overridden but instead hidden."},
    {category: "Class Design",
    sub_category: "Inheriting Variables",
    title: "Hiding Variables",
        content: "When you hide a variable, you define a variable with the same name as a variable in a parent class."},
    {category: "Class Design",
    sub_category: "Inheriting Variables",
    title: "Hiding Variables",
        content: "This creates two copies of the variable within an instance of the child class: one instance defined for the parent reference and another defined for the child reference."},
    {category: "Class Design",
    sub_category: "Inheriting Variables",
    title: "Hiding Variables",
        content: "As when hiding static methods, you can't override a variable - you can only hide it. Also similar to hiding static methods, the rules for accessing the parent and child variables are quite similar."},
    {category: "Class Design",
    sub_category: "Inheriting Variables",
    title: "Hiding Variables",
        content: "If you reference a variable from within the parent class, the variable defined in the parent class is used."},
    {category: "Class Design",
    sub_category: "Inheriting Variables",
    title: "Hiding Variables",
        content: "Alternatively, if you're referencing the variable from within a child class, the variable defined in the child class is used."},
    {category: "Class Design",
    sub_category: "Inheriting Variables",
    title: "Hiding Variables",
        content: "Likewise, you can reference the parent value of the variable with an explicit use of the <code>super</code> keyword."},
    {category: "Class Design",
    sub_category: "Creating Abstract Classes",
    title: "Hiding Variables",
        content: "There is no notion of overriding member variables."},
    {category: "Class Design",
    sub_category: "Creating Abstract Classes",
    title: "",
        content: "An abstract class is a class that is marked with the <code>abstract</code> keyword and cannot be instantiated."},
    {category: "Class Design",
    sub_category: "Defining an Abstract Class",
    title: "",
        content: "An abstract method is a method marked with the <code>abstract</code> keyword defined in an abstract class, for which no implementation is provided in the class in which it is declared."},
    {category: "Class Design",
    sub_category: "Defining an Abstract Class",
    title: "",
        content: "An abstract class may include non-abstract methods and variables."},
    {category: "Class Design",
    sub_category: "Defining an Abstract Class",
    title: "",
        content: "An abstract class is not required to implement any abstract method."},
    {category: "Class Design",
    sub_category: "Defining an Abstract Class",
    title: "",
        content: "An abstract method may only be defined in an abstract class or interface."},
    {category: "Class Design",
    sub_category: "Defining an Abstract Class",
    title: "",
        content: "Abstract methods don't have an implementation code-block. They are terminated with a semicolon after the parameter list / exceptions list."},
    {category: "Class Design",
    sub_category: "Defining an Abstract Class",
    title: "",
        content: "Instantiating an abstract class throws an error."},
    {category: "Class Design",
    sub_category: "Defining an Abstract Class",
    title: "",
        content: "An abstract class can't be marked as <code>final</code>. An abstract class must be extended by another class. If marked as <code>final</code> the class is not reachable by children."},
    {category: "Class Design",
    sub_category: "Defining an Abstract Class",
    title: "",
        content: "An abstract method may not be marked as <code>final</code>, making it impossible to create a concrete instance of the abstract class."},
    {category: "Class Design",
    sub_category: "Creating a Concrete Class",
    title: "",
        content: "An abstract method may not be marked as <code>private</code>. It's impossible to implement since <code>private</code> methods are unreachable to child-methods."},
    {category: "Class Design",
    sub_category: "Creating a Concrete Class",
    title: "",
        content: "Abstract classes cannot be instantiated, therefore they don't do much other than define static variables and methods."},
    {category: "Class Design",
    sub_category: "Creating a Concrete Class",
    title: "",
        content: "A concrete class is the first non-abstract subclass that extends an abstract class and is required to implement all inherited abstract methods."},
    {category: "Class Design",
    sub_category: "Extending an Abstract Class",
    title: "",
        content: "The first concrete class must implement all inherited abstract methods."},
    {category: "Class Design",
    sub_category: "Extending an Abstract Class",
    title: "",
        content: "An extension of an abstract class by an abstract class must not implement the abstract methods from the parent class."},
    {category: "Class Design",
    sub_category: "Extending an Abstract Class",
    title: "",
        content: "The first concrete class must implement all inherited abstract methods from it's parent abstract classes. Even the \"skipped\" ones."},
    {category: "Class Design",
    sub_category: "Extending an Abstract Class",
    title: "",
        content: "A concrete subclass is not required to provide an implementation for an abstract method if an intermediate abstract class provides the implementation."},
    {category: "Class Design",
    sub_category: "Extending an Abstract Class",
    title: "",
        content: "If an intermediate class provides an implementation for an abstract method, that method is inherited by subclasses as a concrete method."},
    {category: "Class Design",
    sub_category: "Extending an Abstract Class",
    title: "",
        content: "Abstract Class Definition Rules: <br>
        1. Abstract classes cannot be instantiated directly.<br>
        2. Abstract classes may be defined with any number, including zero, of abstract and non-abstract methods.<br>
        3. Abstract classes may not be marked as <code>private</code>, <code>protected</code>, or <code>final</code>.<br>
        4. An abstract class that extends another abstract class inherits all of its abstract methods as its own abstract methods.<br>
        5. The first concrete class that extends an abstract class must provide an implementation of all the inherited abstract methods."},
    {category: "Class Design",
    sub_category: "Implementing Interfaces",
    title: "",
        content: "Abstract Method Definition Rules: <br>
        1. Abstract methods may only be defined in abstract classes or interfaces.<br>
        2. Abstract methods may not be declared <code>private</code> or <code>final</code>.<br>
        3. Abstract methods must not provide a method body / implementation in the abstract class for which is it declared.<br>
        4. Implementing an abstract method in a subclass follows the same rules for overriding a method. For example, the name and signature must be the same, and the visibility of the method in the subclass must be at least as accessible as the method in the parent class."},
    {category: "Class Design",
    sub_category: "Implementing Interfaces",
    title: "",
        content: "Java allows classes to implement multiple interfaces."},
    {category: "Class Design",
    sub_category: "Implementing Interfaces",
    title: "",
        content: "An <i>interface</i> is an abstract data type that defines a list of <code>public abstract</code> , <code>public default</code> or <code>public static</code> methods that any class implementing the interface must provide."},
    {category: "Class Design",
    sub_category: "Implementing Interfaces",
    title: "",
        content: "An interface can also include a list of <code>public static final</code> variables."},
    {category: "Class Design",
    sub_category: "Implementing Interfaces",
    title: "",
        content: "Interfaces can only have <code>static</code> and <code>default</code> methods with bodies."},
    {category: "Class Design",
    sub_category: "Implementing Interfaces",
    title: "",
        content: "An interface is defined with the <code>interface</code> keyword."},
    {category: "Class Design",
    sub_category: "Implementing Interfaces",
    title: "",
        content: "A class invokes an interface by using the <code>implements</code> keyword in its class definition."},
    {category: "Class Design",
    sub_category: "Implementing Interfaces",
    title: "",
        content: "Syntax for defining an interface: <br>
        <br>
        <pre><code>public abstract interface CanBurrow {
            public static final int MINIMUM_DEPTH = 2;
            public abstract int getMaximumDepth();
        }</code></pre>
        <br>
        - Interface signature:<br>
            - <code>public</code> - public or default access modifier.<br>
            - <code>abstract</code> - abstract keyword (assumed).<br>
            - <code>interface</code> - interface keyword (required).<br>
            - <code>CanBurrow</code> - interface name.<br>
        - Primitive signature:<br>
            - <code>public static final</code>  - keywords (assumed).<br>
        - Method signature:<br>
            - <code>public abstract</code> - keywords (assumed.)"},
    {category: "Class Design",
    sub_category: "Implementing Interfaces",
    title: "",
        content: "Syntax for implementing an interface: <br>
        <br>
        <pre><code>public class FieldMouse implements CanBurrow {
            public int getMaximumDepth() {
                return 10;
            }
        }</code></pre><br>
        <br>
        - Interface signature:<br>
            - <code>FieldMouse</code> - class name.<br>
            - <code>implements</code> - keyword (required).<br>
            - <code>CanBurrow</code> - interface name.<br>
        - Method signature:<br>
            - <code>public</code> - signature matches interface method."},
    {category: "Class Design",
    sub_category: "Implementing Interfaces",
    title: "",
        content: "A class may implement multiple interfaces, separated by a comma like so:<br>
        - <code>public class Elephant implements WalksOnFourLegs, HasTrunk, Herbivore {}</code>."},
    {category: "Class Design",
    sub_category: "Defining an Interface",
    title: "",
        content: "Rules for creating an interface: <br>
        1. Interfaces cannot be instantiated directly.<br>
        2. An interface is not required to have any methods.<br>
        3. An interface may not be marked as <code>final</code>.<br>
        4. All top-level interfaces are assumed to have <code>public</code> or <i>default</i> access. They are assumed to be <code>abstract</code> whether this keyword is used or not. Therefore, making them <code>private</code>, <code>protected</code> or <code>final</code> will trigger compiler errors as these are incompatible with the <code>abstract</code> and <code>public</code> keywords.<br>
        5. All non-default methods in an interface are assumed to have the modifiers <code>abstract</code> and <code>public</code> in their definition. Therefore, making a method <code>private</code>, <code>protected</code>, or <code>final</code> will trigger compiler errors as these are incompatible with the <code>abstract</code> and <code>public</code> keywords."},
    {category: "Class Design",
    sub_category: "Inheriting an Interface",
    title: "",
        content: "Inheritance rules when extending an interface: <br>
        1. An interface that <code>extends</code> another interface, as well as an abstract class that <code>implements</code> an interface, inherits all of the abstract methods as its own abstract methods.<br>
        2. The first concrete class that <code>implements</code> and interface, or <code>extends</code> an abstract class that <code>implements</code> an interface, must provide an implementation for all the inherited abstract methods."},
    {category: "Class Design",
    sub_category: "Inheriting an Interface",
    title: "",
        content: "An interface may be extended using the <code>extends</code> keyword."},
    {category: "Class Design",
    sub_category: "Inheriting an Interface",
    title: "Classes, Interfaces and Keywords",
        content: "A class can <code>implement</code> an interface, a class cannot <code>extend</code> an interface."},
    {category: "Class Design",
    sub_category: "Inheriting an Interface",
    title: "Classes, Interfaces and Keywords",
        content: "An interface can <code>extend</code> another interface, an interface cannot <code>implement</code> another interface."},
    {category: "Class Design",
    sub_category: "Inheriting an Interface",
    title: "Abstract Methods and Multiple Inheritance",
        content: "Interface methods are abstract and therefore define \"behavior\" that the class implementing the interface must have."},
    {category: "Class Design",
    sub_category: "Inheriting an Interface",
    title: "Abstract Methods and Multiple Inheritance",
        content: "If two abstract interface methods have the same method signature, the second gets implemented automatically."},
    {category: "Class Design",
    sub_category: "Inheriting an Interface",
    title: "Abstract Methods and Multiple Inheritance",
        content: "If two interface methods have the same name but a different parameter list, they get overloaded. Since all abstract methods must be implemented, the return type doesn't matter."},
    {category: "Class Design",
    sub_category: "Inheriting an Interface",
    title: "Abstract Methods and Multiple Inheritance",
        content: "If the method name and input parameters are the same but the return types are different, there will be a compilation error. Reason is that you can't have two methods with the same name and parameter list but different return type in the same class."},
    {category: "Class Design",
    sub_category: "Inheriting an Interface",
    title: "Abstract Methods and Multiple Inheritance",
        content: "Interfaces won't compile if they extend from conflicting interfaces too."},
    {category: "Class Design",
    sub_category: "Interface Variables",
    title: "",
        content: "Interface variables are assumed to be <code>public</code>."},
    {category: "Class Design",
    sub_category: "Interface Variables",
    title: "",
        content: "Unlike interface methods, interface variables are also assumed to be <code>static</code> and <code>final</code>."},
    {category: "Class Design",
    sub_category: "Interface Variables",
    title: "",
        content: "Interface variable rules: <br>
        1. Interface variables are assumed to be <code>public</code>, <code>static</code> and <code>final</code>. Therefore, marking a variable as <code>private</code> or <code>protected</code> will trigger a compiler error, as will marking any variable as <code>abstract</code>.  <br>
        2. The value of an interface variable must be set when it is declared since it is marked as <code>final</code>."},
    {category: "Class Design",
    sub_category: "Default Interface Methods",
    title: "",
        content: "New method since Java 8."},
    {category: "Class Design",
    sub_category: "Default Interface Methods",
    title: "",
        content: "A <i>default method</i> is a method defined within an interface with the <code>default</code> keyword in which a method body is provided."},
    {category: "Class Design",
    sub_category: "Default Interface Methods",
    title: "",
        content: "Compared to \"regular\" methods in an interface, which are assumed to be abstract and may not have a method body."},
    {category: "Class Design",
    sub_category: "Default Interface Methods",
    title: "",
        content: "A default method with an interface defines an abstract method with a default implementation."},
    {category: "Class Design",
    sub_category: "Default Interface Methods",
    title: "",
        content: "Classes have the option to override the default method."},
    {category: "Class Design",
    sub_category: "Default Interface Methods",
    title: "",
        content: "If they don't override the method, it becomes concrete."},
    {category: "Class Design",
    sub_category: "Default Interface Methods",
    title: "",
        content: "All methods within an interface are assumed to be <code>public</code>, therefore the access modifier of a default method is <code>public</code>."},
    {category: "Class Design",
    sub_category: "Default Interface Methods",
    title: "",
        content: "Default interface method rules: <br>
        1. A default method may only be declared within an interface and not within a class or abstract class.<br>
        2. A default method must be marked with the <code>default</code> keyword. If a method is marked as <code>default</code>, it must provide a method body.<br>
        3. A default method is not assumed to be <code>static</code>, <code>final</code>, or <code>abstract</code>, as it may be used or overridden by a class that implements the interface.<br>
        4. Like all methods in an interface, a default method is assumed to be <code>public</code> and will not compile if marked as <code>private</code> or <code>protected</code>."},
    {category: "Class Design",
    sub_category: "Default Interface Methods",
    title: "Default Methods and Multiple Inheritance",
        content: "If a class implements two interfaces that have default methods with the same name and signature, the compiler will throw an error."},
    {category: "Class Design",
    sub_category: "Default Interface Methods",
    title: "Default Methods and Multiple Inheritance",
        content: "If a subclass overrides a duplicate before implementation, the ambiguity has been removed and therefore the code compiles."},
    {category: "Class Design",
    sub_category: "Static Interface Methods",
    title: "",
        content: "Defined with the <code>static</code> keyword they function nearly identically to static methods defined in classes."},
    {category: "Class Design",
    sub_category: "Static Interface Methods",
    title: "",
        content: "The difference is is that a static method defined in an interface is not inherited in any classes that implement the interface."},
    {category: "Class Design",
    sub_category: "Static Interface Methods",
    title: "",
        content: "Static interface method rules: <br>
        1. Like all methods in an interface, a static method is assumed to be <code>public</code> and will not compile if marked <code>private</code> or <code>protected</code>.<br>
        2. To reference the static method, a reference to the name of the interface must be used."},
    {category: "Class Design",
    sub_category: "Static Interface Methods",
    title: "",
        content: "Without an explicit reference to the name of the interface, the code will not compile. <code>Hop.getJumpHeight();</code> - is correct. <code>Hop</code> is the interface name."},
    {category: "Class Design",
    sub_category: "Static Interface Methods",
    title: "",
        content: "If a class implements two interfaces containing duplicate static methods, it will still compile because the methods are not inherited by the subclass and must be accessed with a reference to the interface name."},
    {category: "Class Design",
    sub_category: "Understanding Polymorphism",
    title: "",
        content: "<i>Polymorphism</i> is the property of an object to take on many different forms."},
    {category: "Class Design",
    sub_category: "Understanding Polymorphism",
    title: "",
        content: "A Java object may be accessed using a reference with the same type as the object, a reference that is a superclass of the object, or a reference that defines an interface the object <code>implements</code>, whether directly or through a superclass."},
    {category: "Class Design",
    sub_category: "Understanding Polymorphism",
    title: "",
        content: "A cast is not required if the object is being reassigned to a super type or interface of the object."},
    {category: "Class Design",
    sub_category: "Object vs. Reference",
    title: "",
        content: "In Java all objects are accessed by reference, you have never direct access to the object itself."},
    {category: "Class Design",
    sub_category: "Object vs. Reference",
    title: "",
        content: "Conceptually the object exists in memory, allocated by the Java runtime environment."},
    {category: "Class Design",
    sub_category: "Object vs. Reference",
    title: "",
        content: "Regardless of the type of the reference you have for the object in memory, the object itself doesn't change."},
    {category: "Class Design",
    sub_category: "Object vs. Reference",
    title: "",
        content: "Rules: <br>
        1. The type of the obect determines which properties exist within the object in memory. <br>
        2. The type of the reference to the object determines which methods and variables are accessible to the Java program."},
    {category: "Class Design",
    sub_category: "Object vs. Reference",
    title: "",
        content: "It therefore follows that successfully changing a reference of an object to a new reference may give you access to new properties of the object, but those properties existed before the reference change occurred."},
    {category: "Class Design",
    sub_category: "Casting Objects",
    title: "",
        content: "To reclaim properties from the more specific class, we need to cast the object back to the more specific class."},
    {category: "Class Design",
    sub_category: "Casting Objects",
    title: "",
        content: "Rules for casting variables: <br>
        1. Casting an object from a subclass to a superclass doesn't require an explicit cast. <br>
        2. Casting an object from a superclass to a subclass requires an explicit cast. <br>
        3. The compiler will not allow casts to unrelated types.<br>
        4. Even when the code compiles without issue, an exception may be thrown at runtime if the object being cast is not actually an instance of that class."},
    {category: "Class Design",
    sub_category: "Casting Objects",
    title: "",
        content: "<code>ClassCastException</code> is thrown at runtime every time an object being referenced is not an instance of the class."},
    {category: "Class Design",
    sub_category: "Casting Objects",
    title: "",
        content: "Be sure to remember what the instance of the object actually is. Then, focus on whether the compiler will allow the object to be referenced with or without explicit casts."},
    {category: "Class Design",
    sub_category: "Virtual Methods",
    title: "",
        content: "A <i>virtual method</i> is a method in which the specific implementation is not defined until runtime."},
    {category: "Class Design",
    sub_category: "Virtual Methods",
    title: "",
        content: "All non-final, non-static and non-private Java methods are considered virtual methods, since any of them can be overridden at runtime."},
    {category: "Class Design",
    sub_category: "Virtual Methods",
    title: "",
        content: "What makes a virtual method special in Java is that if you call a method on an object that overrides a method, you get the overridden method, even if the call to the method is on a parent reference or within the parent class."},
    {category: "Class Design",
    sub_category: "Virtual Methods",
    title: "",
        content: "The nature of polymorphism is that an object can take on many forms."},
    {category: "Class Design",
    sub_category: "Virtual Methods",
    title: "",
        content: "Objects may be interpreted in vastly different ways at runtime, especially methods defined in the super-classes of the objects."},
    {category: "Class Design",
    sub_category: "Polymorphic Parameters",
    title: "",
        content: "<i>Polymorphic Parameters</i> is the ability to pass instances of a subclass or interface, to a method."}
])

puts "ðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜ŠCreated: Class Desing"
puts "ðŸ¤”ðŸ¤”ðŸ¤”ðŸ¤”ðŸ¤”ðŸ¤”ðŸ¤”ðŸ¤”ðŸ¤”ðŸ¤”Creating: Exceptions"

Material.create!([
    {category: "Exceptions",
    sub_category: "Understanding Exceptions",
    title: "The Role of Exceptions",
        content: "An <i>exception</i> is Java's way of saying, \"I give up. I don't know what to do right now. You deal with it\"."},
    {category: "Exceptions",
    sub_category: "Understanding Exceptions",
    title: "The Role of Exceptions",
        content: "Exceptions alter the program flow."},
    {category: "Exceptions",
    sub_category: "Understanding Exceptions",
    title: "Understanding Exception Types",
        content: "Java has a <code>Throwable</code> superclass for all objects that represent these events."},
    {category: "Exceptions",
    sub_category: "Understanding Exceptions",
    title: "Understanding Exception Types",
        content: "<code>java.lang.Object</code> â† <code>java.lang.Throwable</code> <br>
        - â† <code>java.lang.Exception</code> â† <code>java.lang.RuntimeException</code> <br>
        - â† <code>java.lang.Error</code>"},
    {category: "Exceptions",
    sub_category: "Understanding Exceptions",
    title: "Understanding Exception Types",
        content: "<i>Error</i> means something went so horribly wrong that the program should not attempt to recover from it."},
    {category: "Exceptions",
    sub_category: "Understanding Exceptions",
    title: "Understanding Exception Types",
        content: "A <i>runtime exception</i> is defined as the <code>RuntimeException</code> class and it's subclasses. Runtime exceptions tend to be unexpected but not necessarily fatal."},
    {category: "Exceptions",
    sub_category: "Understanding Exceptions",
    title: "Understanding Exception Types",
        content: "For example, accessing an invalid array index is unexpected."},
    {category: "Exceptions",
    sub_category: "Understanding Exceptions",
    title: "Understanding Exception Types",
        content: "Runtime exceptions are also known as <i>unchecked exceptions. -</i> Exceptions that occur at the time the program is run."},
    {category: "Exceptions",
    sub_category: "Understanding Exceptions",
    title: "Understanding Exception Types",
        content: "The alternative is compile time, which would be a compiler error."},
    {category: "Exceptions",
    sub_category: "Understanding Exceptions",
    title: "Understanding Exception Types",
        content: "A <i>checked exception</i> includes <code>Exception</code> and all subclasses that do not extend <code>RuntimeException</code>."},
    {category: "Exceptions",
    sub_category: "Understanding Exceptions",
    title: "Understanding Exception Types",
        content: "Checked exceptions tend to be more anticipated, like trying to read a file that doesn't exist."},
    {category: "Exceptions",
    sub_category: "Understanding Exceptions",
    title: "Understanding Exception Types",
        content: "Java has a rule called the <i>handle or declare rule.</i> For checked exceptions, Java requires the code to either handle them or declare them in the method signature."},
    {category: "Exceptions",
    sub_category: "Understanding Exceptions",
    title: "Understanding Exception Types",
        content: "This method declares that it might throw an exception: <br>
        <pre><code>
        void fall() throws Exception {
            throw new Exception();
        }
        </code></pre>"},
    {category: "Exceptions",
    sub_category: "Understanding Exceptions",
    title: "Understanding Exception Types",
        content: "- <code>throws</code> simply declares that the method might throw an Exception."},
    {category: "Exceptions",
    sub_category: "Understanding Exceptions",
    title: "Understanding Exception Types",
        content: "<code>throw new</code> tells Java that you want to throw an Exception."},
    {category: "Exceptions",
    sub_category: "Understanding Exceptions",
    title: "Understanding Exception Types",
        content: "Because checked exceptions tend to be anticipated, Java enforces that the programmer do something to show the exception was thought about."},
    {category: "Exceptions",
    sub_category: "Understanding Exceptions",
    title: "Throwing an Exception",
        content: "Two types of code that result in an exception. <br>
        1. Code that is wrong. <br>
        2. Explicitly request Java to throw an exception."},
    {category: "Exceptions",
    sub_category: "Understanding Exceptions",
    title: "Throwing an Exception",
        content: "<pre><code>
        throw new Exception();
        throw new Exception(\"Ow! I fell.\");
        throw new RuntimeException();
        throw new RuntimeException(\"Ow!, I fell.\");
        </code><pre>"},
    {category: "Exceptions",
    sub_category: "Understanding Exceptions",
    title: "Throwing an Exception",
        content: "When creating an exception, you usually pass a String parameter with a message or you can pass no parameter and use the defaults."},
    {category: "Exceptions",
    sub_category: "Understanding Exceptions",
    title: "Throwing an Exception",
        content: "Types of exception: <br>
        1. Runtime exception â†’ Subclass of <code>RuntimeException</code> â†’ OK for program to catch â†’ Is not required to be handled or declared.<br>
        2. Checked exception â†’ Subclass of <code>Exception</code> but not subclass of <code>RuntimeException</code> â†’ OK for program to catch â†’ Is required to be handled or declared.<br>
        3. Error â†’ Subclass of <code>Error</code> â†’ Not OK for program to catch â†’ Is not required to be handled or declared."},
    {category: "Exceptions",
    sub_category: "Using a <i>try</i> Statement",
    title: "",
        content: "Java uses a <i>try statement</i> to separate the logic that might throw an exception from the logic to handle that exception."},
    {category: "Exceptions",
    sub_category: "Using a <i>try</i> Statement",
    title: "",
        content: "Syntax: <br>

        <pre><code>
        try {
                //The try block is also referred to as protected code
        } catch ( <i>exception_type identifier</i> ) {
                // exception handler
        }
        </code></pre>"},
    {category: "Exceptions",
    sub_category: "Using a <i>try</i> Statement",
    title: "",
        content: "Curly braces are required."},
    {category: "Exceptions",
    sub_category: "Using a <i>try</i> Statement",
    title: "",
        content: "If an exception is thrown in a <code>try</code> statement, the <code>catch</code> clauses attempt to catch it."},
    {category: "Exceptions",
    sub_category: "Using a <i>try</i> Statement",
    title: "",
        content: "The identifier refers to the caught exception object."},
    {category: "Exceptions",
    sub_category: "Using a <i>try</i> Statement",
    title: "",
        content: "If any of the statements in the <code>try</code> block throw an exception, the try block stops running and the execution goes to the <code>catch</code> statement that matched the exception type."},
    {category: "Exceptions",
    sub_category: "Using a <i>try</i> Statement",
    title: "",
        content: "If none of the statements in the <code>try</code> block throw an exception that can be caught, the <i>catch clause</i> is not run."},
    {category: "Exceptions",
    sub_category: "Using a <i>try</i> Statement",
    title: "",
        content: "The try block must have something after it. <code>catch</code> or <code>finally</code>."},
    {category: "Exceptions",
    sub_category: "Using a <i>try</i> Statement",
    title: "Adding a <i>finally</i> block",
        content: "Syntax:

        <pre><code>
        try {
                //protected code
        } catch ( <i>exceptiontype identifier</i> ) {
                //exception handler
        } finally {
                //finnaly block
        }
        </code></pre>"},
    {category: "Exceptions",
    sub_category: "Using a <i>try</i> Statement",
    title: "Adding a <i>finally</i> block",
        content: "The <code>finally</code> block always runs."},
    {category: "Exceptions",
    sub_category: "Using a <i>try</i> Statement",
    title: "Adding a <i>finally</i> block",
        content: "The order must be try â†’ catch â†’ finally."},
    {category: "Exceptions",
    sub_category: "Using a <i>try</i> Statement",
    title: "Adding a <i>finally</i> block",
        content: "If in try or catch block is <code>System.exit(0)</code>, <code>finally</code> does not run."},
    {category: "Exceptions",
    sub_category: "Using a <i>try</i> Statement",
    title: "Catching Various Types of Exceptions",
        content: "I must be able to recognize if the exception is a checked or an unchecked exception."},
    {category: "Exceptions",
    sub_category: "Using a <i>try</i> Statement",
    title: "Catching Various Types of Exceptions",
        content: "I need to determine if any of the exceptions are subclasses of the others."},
    {category: "Exceptions",
    sub_category: "Using a <i>try</i> Statement",
    title: "Catching Various Types of Exceptions",
        content: "Rule for the order of <code>catch</code> blocks â†’ Java looks at them in the order they appear. If it is impossible for one of the <code>catch</code> blocks to be executed, a compiler error about unreachable code occurs. This happens when a superclass is caught before a subclass."},
    {category: "Exceptions",
    sub_category: "Using a <i>try</i> Statement",
    title: "Catching Various Types of Exceptions",
        content: "The more specific Exceptions need to be first in row."},
    {category: "Exceptions",
    sub_category: "Using a <i>try</i> Statement",
    title: "Catching Various Types of Exceptions",
        content: "At most one <code>catch</code> block will run and it will be the first that can handle it."},
    {category: "Exceptions",
    sub_category: "Using a <i>try</i> Statement",
    title: "Throwing a Second Exception",
        content: "A <code>catch</code> that throws an exception will be ignored if the <code>finally</code> throws an exception."},
    {category: "Exceptions",
    sub_category: "Recognizing Common Exception Types",
    title: "",
        content: "I need to recognize 3 types of exceptions: runtime exceptions, checked exceptions and errors."},
    {category: "Exceptions",
    sub_category: "Recognizing Common Exception Types",
    title: "",
        content: "I need to recognize which type it is and whether it it's thrown by the JVM or a programmer."},
    {category: "Exceptions",
    sub_category: "Recognizing Common Exception Types",
    title: "",
        content: "By the programmer: <br>
        - <code>IllegalArgumentException</code>, <code>NumberFormatException</code>, <code>IOException</code> & <code>FileNotFoundException</code>."},
    {category: "Exceptions",
    sub_category: "Recognizing Common Exception Types",
    title: "Runtime Exceptions",
        content: "Runtime exceptions extend <code>RumtimeException</code>. They don't have to be handled or declared."},
    {category: "Exceptions",
    sub_category: "Recognizing Common Exception Types",
    title: "Runtime Exceptions",
        content: "Thrown by the JVM: <br>
        1. <code>ArithmeticException</code> â†’ when code attempts to divide by 0.<br>
            - <code>Exception in thread \"main\" java.lang.ArithmeticException: / by zero</code> .<br>
        2. <code>ArrayIndexOutOfBoundsException</code> â†’ when code uses an illegal index to access an array.<br>
            - <code>Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: -1</code>.<br>
        3. <code>ClassCastException</code> â†’ when an attempt is made to cast an object to a subclass of which it is not an instance.<br>
            - <code>Exception in thread \"main\" java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer</code>.<br>
        4. <code>NullPointerException</code> â†’ when there is a null reference where an object is required.<br>
            - <code>Exception in thread \"main\" java.lang.NullPointerException</code>."},
    {category: "Exceptions",
    sub_category: "Recognizing Common Exception Types",
    title: "Runtime Exceptions",
        content: "Thrown by the programmer: <br>
        1. <code>IllegalArgumentException</code> â†’ indicate that a method has been passed an illegal or inappropriate argument.<br>
            - <code>Exception in thread \"main\" java.lang.IllegalArgumentException: \"the string passed into throw new IllegalArgumentException(\"THE STRING\")\"</code>.<br>
        2. <code>NumberFormatException</code> â†’ when an attempt is made to convert a string to a numeric type but the string doesn't have an appropriate format.<br>
            - <code>Exception in thread \"main\" java.lang.NumberFormatException: For input string: \"abc\"</code>."},
    {category: "Exceptions",
    sub_category: "Recognizing Common Exception Types",
    title: "Checked Exceptions",
        content: "Checked exceptions have <code>Exception</code> in their hierarchy but not <code>RuntimeException</code>."},
    {category: "Exceptions",
    sub_category: "Recognizing Common Exception Types",
    title: "Checked Exceptions",
        content: "They must be handled or declared."},
    {category: "Exceptions",
    sub_category: "Recognizing Common Exception Types",
    title: "Checked Exceptions",
        content: "They can be thrown by the programmer or by the JVM. <br>
        1. <code>IOException</code> â†’ Thrown programmatically when there's a problem reading or writing a file.<br>
            - These are checked exceptions.<br>
        2. <code>FileNotFoundException</code> â†’ Thrown programmatically when there is a problem reading or writing a file that does not exist.<br>
            - <code>FileNotFoundException</code> is a subclass of <code>IOException</code>."},
    {category: "Exceptions",
    sub_category: "Recognizing Common Exception Types",
    title: "Errors",
        content: "Errors extend the Error class."},
    {category: "Exceptions",
    sub_category: "Recognizing Common Exception Types",
    title: "Errors",
        content: "They are thrown by the JVM."},
    {category: "Exceptions",
    sub_category: "Recognizing Common Exception Types",
    title: "Errors",
        content: "They should not be handled or declared. <br>
        1. <code>ExceptionInInitializerError</code> â†’ Thrown by the JVM when a static initializer throws an exception and doesn't handle it.<br>
            - If one of the static initializers throws an exception, Java can't start using the class.<br>
            - <code>Exception in thread \"main\" java.lang.ExceptionInInitializerError Caused by: java.lang.ArrayIndexOutOfBoundsException: -1</code>.<br>
        2. <code>StackOverflowError</code> â†’ Thrown by the JVM when a method calls itself too many times. (infinite recursion).<br>
            - <code>Exception in thread \"main\" java.lang.StackOverflowError</code>.<br>
        3. <code>NoClassDefFoundError</code> â†’ Thrown by the JVM when a class that the code uses is available at compile time but not runtime."},
    {category: "Exceptions",
    sub_category: "Calling Methods That Throw Exceptions",
    title: "Subclasses",
        content: "When a class overrides a method from a superclass or implements a method from an interface, it's not allowed to add new checked exceptions to the method signature."},
    {category: "Exceptions",
    sub_category: "Calling Methods That Throw Exceptions",
    title: "Printing an Exception",
        content: "3 ways to print an exception: <br>
        - <code>System.out.println(e);</code><br>
        - <code>System.out.println(e.getMessage());</code><br>
        - <code>e.printStackTrace();</code>"}
])

puts "ðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜ŠCreated: Exceptions"

puts "ðŸ˜ŠCreating: Flipcards"


puts "ðŸ˜€ðŸ˜€ðŸ˜€ðŸ˜€ðŸ˜€ðŸ˜€ðŸ˜€ðŸ˜€ðŸ˜€ðŸ˜€ðŸ˜€ðŸ˜€Database Seed Completed!"